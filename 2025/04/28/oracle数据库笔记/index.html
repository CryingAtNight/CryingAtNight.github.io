<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Oracle数据库笔记 | Yinjin Yao的博客</title><meta name="author" content="Yinjin Yao"><meta name="copyright" content="Yinjin Yao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是数据库 数据库（Database，DB）  数据库管理系统（Batabase Management System，DBMS）  结构化查询语言（Structured Query Language，SQL）  关系型数据库（Relational Database，RDB）：目前应用最广泛的数据库。 常见的五种关系型数据库管理系统：①Oracle Database：甲骨文公司②SQL Serve">
<meta property="og:type" content="article">
<meta property="og:title" content="Oracle数据库笔记">
<meta property="og:url" content="https://cryingatnight.github.io/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Yinjin Yao的博客">
<meta property="og:description" content="什么是数据库 数据库（Database，DB）  数据库管理系统（Batabase Management System，DBMS）  结构化查询语言（Structured Query Language，SQL）  关系型数据库（Relational Database，RDB）：目前应用最广泛的数据库。 常见的五种关系型数据库管理系统：①Oracle Database：甲骨文公司②SQL Serve">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cryingatnight.github.io/img/%E4%BA%94%E6%9D%A1%E6%82%9F.jpg">
<meta property="article:published_time" content="2025-04-28T04:00:00.000Z">
<meta property="article:modified_time" content="2025-07-21T01:29:41.034Z">
<meta property="article:author" content="Yinjin Yao">
<meta property="article:tag" content="Oracle">
<meta property="article:tag" content="SQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cryingatnight.github.io/img/%E4%BA%94%E6%9D%A1%E6%82%9F.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Oracle数据库笔记",
  "url": "https://cryingatnight.github.io/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/",
  "image": "https://cryingatnight.github.io/img/%E4%BA%94%E6%9D%A1%E6%82%9F.jpg",
  "datePublished": "2025-04-28T04:00:00.000Z",
  "dateModified": "2025-07-21T01:29:41.034Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yinjin Yao",
      "url": "https://cryingatnight.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/headimage.png"><link rel="canonical" href="https://cryingatnight.github.io/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Oracle数据库笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/headimage.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-flask"></i><span> 实验室</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://121.199.61.105/"><i class="fa-fw fas fa-q"></i><span> 豆瓣网开发</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fuckornot.on.websim.com/"><i class="fa-fw fa fa-trophy"></i><span> 上不上AI评分系统</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fontawesome.com/icons"><i class="fa-fw fa fa-check-circle"></i><span> font-awesome v6 图标</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/%E4%BA%94%E6%9D%A1%E6%82%9F.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/headimage.png" alt="Logo"><span class="site-name">Yinjin Yao的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Oracle数据库笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-flask"></i><span> 实验室</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://121.199.61.105/"><i class="fa-fw fas fa-q"></i><span> 豆瓣网开发</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fuckornot.on.websim.com/"><i class="fa-fw fa fa-trophy"></i><span> 上不上AI评分系统</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fontawesome.com/icons"><i class="fa-fw fa fa-check-circle"></i><span> font-awesome v6 图标</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Oracle数据库笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-28T04:00:00.000Z" title="发表于 2025-04-28 12:00:00">2025-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-21T01:29:41.034Z" title="更新于 2025-07-21 09:29:41">2025-07-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h1><ul>
<li><p>数据库（Database，DB）</p>
</li>
<li><p>数据库管理系统（Batabase Management System，DBMS）</p>
</li>
<li><p>结构化查询语言（Structured Query Language，SQL）</p>
</li>
<li><p>关系型数据库（Relational Database，RDB）：目前应用最广泛的数据库。</p>
<p>常见的五种关系型数据库管理系统：<br>①Oracle Database：甲骨文公司<br>②SQL Server：微软公司<br>③DB2：IBM 公司<br>④PostgreSQL：开源<br>⑤MySQL：开源</p>
</li>
</ul>
<h2 id="术语及概念简单介绍"><a href="#术语及概念简单介绍" class="headerlink" title="术语及概念简单介绍"></a>术语及概念简单介绍</h2><ol>
<li>服务器：用于接收并处理其它程序发出的请求的程序（软件），或者是安装此类程序的设备（计算机）。</li>
<li>客户端：向服务器发出请求的程序（软件），或者是安装此类程序的设备（计算机）。</li>
<li><strong>表（table）</strong>：类似 Excel，由行和列组成的二维表。行（Row）和列（Column）</li>
<li><strong>字段</strong>：表中的列（垂直方向），叫做一个字段</li>
<li><strong>记录</strong>：表的行（水平方向），叫做一条记录。【注意】关系数据库必须以行为单位进行数据读写。</li>
<li><strong>单元格</strong>：行列交汇处。【注意】与 Excel 不同，一个单元格只能输入一个数据。</li>
</ol>
<h2 id="SQL是什么？"><a href="#SQL是什么？" class="headerlink" title="SQL是什么？"></a>SQL是什么？</h2><ul>
<li><p>结构化查询语言(Structured Query Language)，是数据库编程的核心语言。</p>
</li>
<li><p>SQL 语句：用关键字、表名和列名等组合而成的一条语句。</p>
</li>
<li><p>SQL非常接近英语，关键字其实都是英文单词，记住单词的意思，使用起来非常简单。</p>
</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量一般是指在操作系统中用来&#x3D;&#x3D;指定操作系统运行环境的一些参数&#x3D;&#x3D;。</p>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><ol>
<li><strong>DQL</strong>（Data Query Language，数据查询语言）:一种用于从数据库中检索数据的语<br>言,代表关键字为select。</li>
<li><strong>DDL</strong>（Data Definition Language，数据定义语言）:用来创建数据库中的各种对象，<br>创建、删除、修改表的结构，代表关键字为create、drop、alter。</li>
<li><strong>DML</strong>（Data Manipulation Language，数据操作语言）:用于数据库中对数据的操<br>纵，代表关键字为insert、delete 、update。</li>
<li><strong>DCL</strong>（Data Control Language，数据控制语言）:用来授予或回收访问数据库的某种<br>特权。代表关键字为grant、revoke。</li>
<li><strong>TCL</strong>（Trasactional Control Languag, 事务控制语言）：用于维护数据的一致性，包<br>括commit、rollback和savepoint三条语句。</li>
</ol>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>关键字：<strong>distinct</strong></p>
<p>如果希望一个列表没有重复值，可以利用distinct子句从结果集中除去重复的行。</p>
<p>格式：SELECT DISTINCT 列名称 FROM 表名;</p>
<p>distinct 它只能放在所有列的最前面（它的前面不能写任何列）</p>
<p>distinct 单列：对单列进行去重<br>distinct 多列：&#x3D;&#x3D;当且仅当所有列的值同时相等时，才是重复数据&#x3D;&#x3D;</p>
<p>select distinct deptno from emp;</p>
<h2 id="dual虚拟表"><a href="#dual虚拟表" class="headerlink" title="dual虚拟表"></a>dual虚拟表</h2><p>dual是个虚拟表，&#x3D;&#x3D;只有一行一列，基本上oracle引入dual为的就是符合语法！&#x3D;&#x3D;</p>
<p>因为在oracle当中查询语句必须要有关键字 select ….from tablename; 只有这样语句才完<br>整，要是没有表名就无法查询，而时间，日期等不存在于任何表，这个时候就引入了<br>dual 虚表的概念。</p>
<h2 id="伪列"><a href="#伪列" class="headerlink" title="伪列"></a>伪列</h2><p>rownum:不是在物理上真实存在的列，它是对查询结果给了一个从一开始的排列数据，<br>获取到结果集之后再加上去的一个列</p>
<p>ROWNUM与ROWID不同，&#x3D;&#x3D;ROWID是插入记录时生成，ROWNUM是查询数据时生成。&#x3D;&#x3D;<br>ROWID标识的是行的<code>物理地址</code>。ROWNUM标识的是查询结果中的<code>行的次序</code>。<br>通过ROWNUM伪列可以限制查询结果集中返回的行数</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li><strong>char</strong>类型，最大长度2000个字节，区别与C语言的char类型一个字节。</li>
<li><strong>varchar2</strong>存储字符串类型，根据数据实际长度自动调整，最大长度4000个字节。</li>
<li><strong>number</strong>类型具有精度，格式number(SCALE,PRECISION), 精度指定所有数字位的个数，范围指定小数的位数。</li>
<li><strong>data</strong>类型  存储日期和时间的组合数。</li>
<li>**timestamp:**时间戳类型,可存放世纪、纪元、年、月、日、时、分、秒还可以存放秒后6位。</li>
</ul>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><ul>
<li><p>1NF 原子性的，不可分。即实体中的某个属性不能有多个值或者不能有重复的属性。</p>
</li>
<li><p>2NF 实体的属性完全依赖于主关键字。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。</p>
</li>
<li><p>3NF 表中不包含已在其它表中已包含的非主关键字信息。</p>
<p><strong>用我的话理解就是：</strong></p>
<ol>
<li><strong>第一范式：原子性不可分。实体中的属性不能有多个值或多个重复属性。</strong></li>
<li><strong>第二范式：实体属性完全依赖主键。</strong></li>
<li><strong>第三范式：表中不含有其他表中的非主键信息。</strong></li>
</ol>
</li>
</ul>
<h2 id="表和表空间的关系"><a href="#表和表空间的关系" class="headerlink" title="表和表空间的关系"></a>表和表空间的关系</h2><ul>
<li>一个表只能属于一个表空间，</li>
<li>一个表空间可以放任意多个表</li>
<li>一个表空间至少有一个存储文件.dbf文件，可以有多个，而且这多个数据文件可以在不同 位置 </li>
<li>一个用户有一个默认的表空间，一个用户可以在默认表空间外的其它表空间建表</li>
</ul>
<h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a><strong>创建表空间</strong></h3><p>create tablespace 表空间名 datafile ‘数据文件路径’ size 初始大小（2G） autoextend on next 每次扩展的大小(100M) maxsize 最大容量（unlimited）;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> tablespace ora</span><br><span class="line">datafile <span class="string">&#x27;c:\test\tab.dbf&#x27;</span></span><br><span class="line">size <span class="number">2</span>G autoextend <span class="keyword">on</span> next <span class="number">100</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure>

<h3 id="创建临时表空间："><a href="#创建临时表空间：" class="headerlink" title="创建临时表空间："></a><strong>创建临时表空间：</strong></h3><p>create temporary tablespace 临时表空间名 tempfile ‘数据文件路径’ size 初始大小</p>
<p>（2G） autoextend on next 每次扩展的大小(100M) maxsize 最大容量（unlimited）;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary tablespace tabtemp</span><br><span class="line">tempfile <span class="string">&#x27;c:\test\tabtemp.dbf&#x27;</span></span><br><span class="line">size <span class="number">2</span>G autoextend <span class="keyword">on</span> next <span class="number">100</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h3><p>create user 用户名 identified by 密码 default tablespace 表空间名 temporary tablespace</p>
<p>临时表空间名;</p>
<p>default后面的语句是为用户指定默认表空间和临时表空间，如果不指定，默认的表空间是users表空间，临时表空间是temp</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> orastudy</span><br><span class="line">identified <span class="keyword">by</span> oracle <span class="keyword">default</span> tablespace ora temporary tablespace tabtemp;</span><br></pre></td></tr></table></figure>

<h3 id="用户权限赋予"><a href="#用户权限赋予" class="headerlink" title="用户权限赋予"></a><strong>用户权限赋予</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">to</span> 用户名;</span><br><span class="line"><span class="keyword">grant</span> resource,<span class="keyword">connect</span> <span class="keyword">to</span> ora; <span class="comment">--连接权限和资源权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">to</span> ora; <span class="comment">--建表权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">any</span> tablespace <span class="keyword">to</span> ora; <span class="comment">--建表空间权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">to</span> ora; <span class="comment">--只读权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">any</span> <span class="keyword">view</span> <span class="keyword">to</span> bw; <span class="comment">--创建视图权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">to</span> ora; <span class="comment">--给ora用户预编译表的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看角色权限信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> role_sys_privs;</span><br><span class="line"><span class="keyword">grant</span> dba <span class="keyword">to</span> ora; <span class="comment">--管理员权限</span></span><br></pre></td></tr></table></figure>



<h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a><strong>删除表空间</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> tablespace student1 including contents;</span><br></pre></td></tr></table></figure>

<p>including contents选项用于删除表空间时包含其内容。如果不使用这个选项，表空间会被删除，但数据文件仍然存在，磁盘空间不会被释放。使用这个选项可以确保表空间及其内容被完全删除，从而释放磁盘空间</p>
<h3 id="扩容-表空间"><a href="#扩容-表空间" class="headerlink" title="扩容 表空间"></a><strong>扩容 表空间</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> tablespace student</span><br><span class="line"><span class="keyword">add</span> datafile <span class="string">&#x27;C:\test\student.dbf&#x27;</span> size <span class="number">100</span>m autoextend <span class="keyword">on</span> next <span class="number">10</span>m maxsize unlimited;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="1-列级约束（Column-Level-Constraints）"><a href="#1-列级约束（Column-Level-Constraints）" class="headerlink" title="1. 列级约束（Column-Level Constraints）"></a><strong>1. 列级约束（Column-Level Constraints）</strong></h3><p> <strong>定义位置</strong>：直接在<strong>列的定义中</strong>声明约束。</p>
<p><strong>适用场景</strong>：约束仅作用于<strong>单个列</strong>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><p>简洁直观，适合单列约束。</p>
</li>
<li><p>无法定义涉及多列的约束（如复合主键）。</p>
</li>
<li><p>外键约束的列级语法需要直接引用父表列。</p>
</li>
</ul>
<h3 id="2-表级约束（Table-Level-Constraints）"><a href="#2-表级约束（Table-Level-Constraints）" class="headerlink" title="2. 表级约束（Table-Level Constraints）"></a><strong>2. 表级约束（Table-Level Constraints）</strong></h3><ul>
<li><p><strong>定义位置</strong>：在<strong>所有列定义之后</strong>单独声明约束。所有使用alter语句添加的约束基本都是 表级约束。</p>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><p>约束涉及<strong>多个列</strong>（如复合主键、联合唯一键）。</p>
</li>
<li><p>需要显式命名约束（便于后续管理）。</p>
</li>
<li><p>外键约束需要指定父表列名。<br> [ CONSTRAINT &lt;约束名&gt; ] &lt;约束类型&gt; 约束名：约束不指定名称时，系统会给定一个名称。</p>
</li>
</ul>
</li>
</ul>
<h3 id="六大约束"><a href="#六大约束" class="headerlink" title="六大约束"></a>六大约束</h3><ol>
<li><p>非空约束 <strong>not null</strong></p>
</li>
<li><p>默认约束 <strong>default</strong></p>
</li>
<li><p>唯一约束 <strong>unique</strong></p>
</li>
<li><p>主键约束 <strong>primary key</strong></p>
</li>
<li><p>检查约束 <strong>check(条件表达式)</strong></p>
</li>
<li><p>外键约束 <strong>references 主表(主键列)</strong></p>
<p> &#x3D;&#x3D;另起一行constraint开头的是表级约束&#x3D;&#x3D;</p>
</li>
</ol>
<h1 id="操作符与增删改"><a href="#操作符与增删改" class="headerlink" title="操作符与增删改"></a>操作符与增删改</h1><h2 id="insert插入"><a href="#insert插入" class="headerlink" title="insert插入"></a>insert插入</h2><ul>
<li><p>Insert into 表名(列名1，列名2，列名3)values(value1，value2,value3);</p>
</li>
<li><p>Insert into 表名 values (value1,value2,value3);</p>
<p>  <strong>如果值中需要空值，需要在value中输入null</strong></p>
</li>
<li><p>Insert into 表名(列名1，列名2，列名3) select * from 表名 where</p>
<p>  插入一整个表</p>
</li>
</ul>
<h2 id="update修改"><a href="#update修改" class="headerlink" title="update修改"></a>update修改</h2><ul>
<li><p>Update 表名 set 列名 &#x3D;’values’ ,列名&#x3D;’values’ where</p>
</li>
<li><p>Update 表名 set 列名&#x3D;(select * from 表名) where</p>
</li>
</ul>
<h2 id="delete删除"><a href="#delete删除" class="headerlink" title="delete删除"></a>delete删除</h2><p><strong>delete删除的是一整条记录，而不是其中一个字段值。</strong></p>
<ul>
<li>Delete from 表 where 条件</li>
<li>Delete from 表 where sal&gt;(select avg(hissal) from salgrade where grade&#x3D;4)</li>
</ul>
<h2 id="delete，drop，truncate的区别"><a href="#delete，drop，truncate的区别" class="headerlink" title="delete，drop，truncate的区别"></a>delete，drop，truncate的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">delete</th>
<th align="center">turncate</th>
<th align="center">drop</th>
</tr>
</thead>
<tbody><tr>
<td align="center">删除表数据</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">删除表结构</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">是否能回滚</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">执行速度</td>
<td align="center">慢</td>
<td align="center">中</td>
<td align="center">快</td>
</tr>
</tbody></table>
<h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a><strong>Merge</strong></h2><p><strong>根据与源表联接的结果，对目标表执行插入、更新或删除操作。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Merge</span> <span class="keyword">into</span> 目标表 <span class="keyword">as</span> 别名</span><br><span class="line"><span class="keyword">Using</span> 源表 <span class="keyword">as</span> 别名</span><br><span class="line"><span class="keyword">On</span> (<span class="keyword">values</span><span class="operator">=</span><span class="keyword">values</span> <span class="operator">|</span><span class="keyword">and</span> )</span><br><span class="line"><span class="keyword">When</span> matched <span class="keyword">then</span> <span class="keyword">update</span> 和 <span class="keyword">delete</span> <span class="comment">--匹配则更新和删除</span></span><br><span class="line"><span class="keyword">When</span> <span class="keyword">not</span> matched <span class="keyword">then</span> <span class="keyword">insert</span>       <span class="comment">--不匹配则插入</span></span><br></pre></td></tr></table></figure>

<h2 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h2><p>   <strong>算术操作符&gt;链接操作符&gt;比较操作符合&gt;not逻辑操作符&gt;and逻辑操作符&gt;or逻辑操作符</strong><br> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;all: 表示大于最大值        大于全部值</span><br><span class="line">&lt;all：表示小于最小值        小于全部值</span><br><span class="line">&gt;any：表示大于最小值		大于任意一个值		</span><br><span class="line">&lt;any：表示小于最大值   		小于任意一个值</span><br><span class="line">=any: 和in类似				等于任意一个值</span><br></pre></td></tr></table></figure><br><strong>and取交集<br>or取并集<br>not取反结果</strong></p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">between…and…</td>
<td align="left">在两个值之间(包含边界)</td>
</tr>
<tr>
<td align="center">in(set)</td>
<td align="left">等于值列表中的一个</td>
</tr>
<tr>
<td align="center">like</td>
<td align="left">模糊查询</td>
</tr>
<tr>
<td align="center">is null</td>
<td align="left">空值</td>
</tr>
</tbody></table>
<p>like：<br>在where子句中使用like关键字查询数据的方式也称为<strong>字符串模式匹配</strong>或字符串模糊查询，like关键字需要使用通配符在字符串内查找指定的模式。</p>
<p><em>要查询的字符串中含有<strong>“%”</strong>或__“</em>”时，可以使用转义（escape）关键字实现。</p>
<p>在“\”之后的“<em>”<strong>字符已不是通配符，而是他</strong>本来的含义</em></p>
<h1 id="排列、分组查询"><a href="#排列、分组查询" class="headerlink" title="排列、分组查询"></a>排列、分组查询</h1><h2 id="排列查询"><a href="#排列查询" class="headerlink" title="排列查询"></a>排列查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> col_name1,col_name2....(<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span>:排列查询的关键字</span><br><span class="line"><span class="keyword">by</span>:介词，后面跟列名</span><br><span class="line"><span class="keyword">asc</span>:升序（默认）</span><br><span class="line"><span class="keyword">desc</span>:降序</span><br></pre></td></tr></table></figure>

<p><strong>order by 是唯一一个可以使用别名的关键词,与sql语句的执行顺序有关</strong> </p>
<p>&#96;注意：</p>
<p><code>降序排序时如果有空值，那么空值会作为最大值排在最前面</code></p>
<p><code>可以在order by后通过数字指定列进行排序，通常不使用这种方法</code></p>
<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>目的是用来<strong>汇总数据或为某个分组显示单行的汇总信息</strong>，通常在查询结果集</p>
<p>中使用group by 子句对记录进行分组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> col_name</span><br><span class="line"><span class="keyword">group</span>:分组的关键字</span><br><span class="line"><span class="keyword">by</span>:介词，后面加列名</span><br><span class="line"><span class="keyword">Having</span>：过滤组关键字</span><br></pre></td></tr></table></figure>

<p>聚合函数：定义：也叫组函数，<strong>对一组数据（一列或多列）进行处理，返回单个结果</strong></p>
<p>使用group by子句和聚合函数，可以实现对查询结果中每一组数据进行分类统计。</p>
<h3 id="where-和-having的区别"><a href="#where-和-having的区别" class="headerlink" title="where 和 having的区别"></a>where 和 having的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">where</th>
<th align="center">having</th>
</tr>
</thead>
<tbody><tr>
<td align="center">处理目标</td>
<td align="center">行过滤</td>
<td align="center">分组过滤</td>
</tr>
<tr>
<td align="center">书写位置</td>
<td align="center">from后</td>
<td align="center">一般在group by后</td>
</tr>
<tr>
<td align="center">执行优先</td>
<td align="center">分组前过滤</td>
<td align="center">分组后过滤</td>
</tr>
<tr>
<td align="center">是否加过滤条件</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">加聚会函数过滤条件</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">效率</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
</tbody></table>
<h3 id="where条件里为什么不能有聚合函数"><a href="#where条件里为什么不能有聚合函数" class="headerlink" title="where条件里为什么不能有聚合函数"></a>where条件里为什么不能有聚合函数</h3><p>基于整列数据进行计算的，而where子句则是对数据行进行过滤的(这里过滤是在一个记录里边过滤的,基于”行”<br>为聚集函数要对全列数据时行计算，因而<strong>使用它的前提是：结果集已经确定</strong>！</p>
<h1 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h1><p>递归查询的书写方案</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TO</span> <span class="type">DATE</span>(<span class="number">2017</span><span class="number">-12</span><span class="number">-01</span><span class="string">&#x27;,&#x27;</span>YYYY <span class="operator">-</span> MM <span class="operator">-</span> DD<span class="string">&#x27;)+LEVEL * INTERVAL&#x27;</span><span class="number">1</span><span class="string">&#x27;day</span></span><br><span class="line"><span class="string">FROM dual</span></span><br><span class="line"><span class="string">CONNECT BY LEVEL &lt;=24</span></span><br></pre></td></tr></table></figure>



<h1 id="同环比"><a href="#同环比" class="headerlink" title="同环比"></a>同环比</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.dat,a.amount,b.amount,c.amount</span><br><span class="line"><span class="keyword">from</span> tab a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab b <span class="keyword">on</span> to_date (a.dat,<span class="string">&#x27;yyyymm&#x27;</span>)<span class="operator">=</span>add_months(to_date(b.dat,<span class="string">&#x27;yyyymm&#x27;</span>),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab c <span class="keyword">on</span> to_date(a.dat,<span class="string">&#x27;yyyymm&#x27;</span>)<span class="operator">=</span>add_months(to_date(c.dat,<span class="string">&#x27;yyyymm&#x27;</span>),<span class="number">12</span>)</span><br><span class="line">                                                               </span><br><span class="line">                                                               </span><br><span class="line"><span class="keyword">select</span> a.dat,a.year,a.month a.amount</span><br><span class="line"><span class="keyword">from</span> tab a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tab b <span class="keyword">on</span> ta.year<span class="operator">=</span>b.year <span class="keyword">and</span> a.month<span class="operator">=</span>b.month<span class="operator">+</span><span class="number">1</span>)<span class="keyword">or</span> (a.year<span class="operator">=</span>b.year<span class="operator">+</span><span class="number">1</span> <span class="keyword">and</span> a.month<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b.month<span class="operator">=</span><span class="number">12</span>)</span><br><span class="line"><span class="keyword">Left</span> <span class="keyword">join</span> tab c <span class="keyword">on</span> a.month<span class="operator">=</span>c.month <span class="keyword">and</span> a.year<span class="operator">=</span>c.year<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure>


<h1 id="关键词执行顺序"><a href="#关键词执行顺序" class="headerlink" title="关键词执行顺序"></a>关键词执行顺序</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">目标</th>
<th align="center">书写顺序</th>
<th align="center">执行顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">列</td>
<td align="center">1</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">from</td>
<td align="center">表</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">where</td>
<td align="center">条件</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">group by</td>
<td align="center">列</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">having</td>
<td align="center">条件:聚合</td>
<td align="center">5</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">order by</td>
<td align="center">列</td>
<td align="center">6</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p><strong>分组后select 后面只能跟分了组的列和聚合函数<br>group by后面产生所有的聚合函数，select只是展示</strong></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h1><p><strong>函数:SQL 函数会对传递进来的参数进行处理，并返回一个处理结果，也就是返回一个值。</strong></p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><table>
<thead>
<tr>
<th>序号</th>
<th>函数名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>length(str)</td>
<td>返回一个字符串长度</td>
</tr>
<tr>
<td>2</td>
<td>concat(str1,str2)</td>
<td>字符串连接函数</td>
</tr>
<tr>
<td>3</td>
<td>chr()</td>
<td>将一个ASCII码转换为字符</td>
</tr>
<tr>
<td>4</td>
<td>ascii(字符)</td>
<td>将一个字符转换为ASCII码值，ASCII码转换的是键盘交互的所有的键</td>
</tr>
<tr>
<td>5</td>
<td>instr(str1,str2,start,n)</td>
<td>instr(源字符串,目标字符串,开始位置,匹配序号)，返回匹配位置的下标。替换like 查找第几位有什么字符，确定原始字符里有多少个字符。如果start是负数，则从后往前数，从前往后截取。</td>
</tr>
<tr>
<td>6</td>
<td>substr(str,start,len)</td>
<td>从start位置开始截取长度为len的字符串，返回一个字符串。如果start是负数，则从后往前数，到开始位置停下了往后截取。</td>
</tr>
<tr>
<td>7</td>
<td>initcap(str)</td>
<td>将首字母大写其他字母小写(以空格来区分单词的)</td>
</tr>
<tr>
<td>8</td>
<td>lower&#x2F;upper()</td>
<td>大小写转换函数</td>
</tr>
<tr>
<td>9</td>
<td>replace(str,s,d)</td>
<td>字符串替换函数，将字符串str中的s字符替换成字符d。使用功能: 1. 替换 2.删除 3.脱敏</td>
</tr>
<tr>
<td>10</td>
<td>translate(char, from,to)</td>
<td>返回将出现在from中的每个字符替换为to中的相应字符</td>
</tr>
<tr>
<td>11</td>
<td>round(num,[num1,])</td>
<td>四舍五入函数，num1是正数时精度是正数小数点之后，是负数时小数点之前</td>
</tr>
<tr>
<td>12</td>
<td>mod(num1，num2)</td>
<td>求余函数</td>
</tr>
<tr>
<td>13</td>
<td>trunc()</td>
<td>截取函数</td>
</tr>
<tr>
<td>14</td>
<td>floor()</td>
<td>向下取整</td>
</tr>
<tr>
<td>15</td>
<td>ceil()</td>
<td>向上取整</td>
</tr>
<tr>
<td>16</td>
<td>power(n, m)</td>
<td>返回n的m次幂</td>
</tr>
<tr>
<td>17</td>
<td>sqrt(n)</td>
<td>返回数字n的平方根</td>
</tr>
<tr>
<td>18</td>
<td>to_date(str)</td>
<td>将字符串转换成日期yyyy,MM,dd,hh24,mi,ss</td>
</tr>
<tr>
<td>19</td>
<td>to_number()</td>
<td>将字符串转换成数字</td>
</tr>
<tr>
<td>20</td>
<td>to_char()</td>
<td>字符串转换函数。跟日期有关的不管是日期转字符还是字符转日期都要带日期格式。to_char()的站位用法：’990.99’:9代表占一个位置，0代表把小数点之前的0补齐</td>
</tr>
<tr>
<td>21</td>
<td>last_day(日期)</td>
<td>取当前日期月的最后一天</td>
</tr>
<tr>
<td>22</td>
<td>next_day(sysdate,n)</td>
<td>取下一个(最近的)一周的第几天，1是星期日</td>
</tr>
<tr>
<td>23</td>
<td>add_months(日期,月)</td>
<td>给一个日期加上若干个月</td>
</tr>
<tr>
<td>24</td>
<td>months_between(date1,date2)</td>
<td>取两个日期相差的月数</td>
</tr>
<tr>
<td>25</td>
<td>nvl2(列名,值1,值2)</td>
<td>空值转换函数，当第一个参数的值是空时，返回结果是第3个参数的值，当第一个参数不为空时，返回结果是第2个参数的值</td>
</tr>
</tbody></table>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li><p>隐式转换<br> 指Oracle在执行SQL语句时自动将数据类型转换成需要的数据类型。<strong>隐式转换可能会导致精度损失或数据不准确，</strong>因此在使用时需要谨慎。</p>
</li>
<li><p>显示转换<br> 显式转换是指在SQL语句中使用一些函数<strong>强制将某个数据类型转换成另一个数据类型</strong>。<br> to_number ：字符转换为数字<br> to_date()：作用将字符类型按一定格式转化为日期类型。<br> to_char 数字转化为字符<br> to_char 日期转化为字符,<strong>必须加单引号,并且区分大小写</strong></p>
</li>
</ol>
<h3 id="转换函数示例"><a href="#转换函数示例" class="headerlink" title="转换函数示例"></a>转换函数示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> to_number(<span class="string">&#x27;0.9890&#x27;</span>)<span class="operator">+</span><span class="number">3</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;1999-09-09 &#x27;</span>,<span class="string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;19990909&#x27;</span>,<span class="string">&#x27;yyyyMMdd&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;1999/09/09 22:56:18&#x27;</span>,<span class="string">&#x27;yyyy/MM/dd hh24:mi:ss&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_date(<span class="number">19990909</span>,<span class="string">&#x27;yyyyMMdd&#x27;</span>) <span class="keyword">from</span> dual;<span class="comment">---数字也可以去转</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="string">&#x27;.83&#x27;</span>,<span class="string">&#x27;0.99&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;dd&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;mm&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;yyyy&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;yyyy/MM/dd hh24:mi:ss&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> last_day(sysdate) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> next_day(sysdate,<span class="number">4</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> add_months(sysdate,<span class="number">-3</span>) <span class="keyword">from</span> dual<span class="comment">--求3个月前的今天</span></span><br><span class="line"><span class="keyword">select</span> sysdate<span class="operator">-</span>hiredate <span class="keyword">from</span> emp;<span class="comment">----得出结果以天为单位的</span></span><br><span class="line"><span class="keyword">select</span> months_between(sysdate,to_date(<span class="string">&#x27;2020-3-3&#x27;</span>,<span class="string">&#x27;yyyy/MM/dd&#x27;</span>)) <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">select</span> comm,nvl2(comm,comm,<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<h2 id="空值赋值nvl"><a href="#空值赋值nvl" class="headerlink" title="空值赋值nvl"></a>空值赋值nvl</h2><p>【语法】NVL (expr1, expr2)<br>【功能】若expr1为NULL，返回expr2；expr1不为NULL，返回expr1。</p>
<p>注意两者的类型要一致</p>
<p>【语法】NVL2 (expr1, expr2, expr3)<br>【功能】expr1不为NULL，返回expr2；expr2为NULL，返回expr3。</p>
<p>expr2和expr3类型不同的话，expr3会转换为expr2的类型</p>
<h2 id="TRANSLATE-c1-c2-c3"><a href="#TRANSLATE-c1-c2-c3" class="headerlink" title="TRANSLATE(c1,c2,c3)"></a>TRANSLATE(c1,c2,c3)</h2><p>【功能】将字符表达式值中，指定字符替换为新字符</p>
<p>c1 希望被替换的字符或变量<br>c2 查询原始的字符集<br>c3 替换新的字符集，将c2对应顺序字符，替换为c3对应顺序字符</p>
<p>如果c3长度大于c2，则c3长出后面的字符无效<br>如果c3长度小于c2，则c2长出后面的字符均替换为空(删除)<br>如果c3长度为0，则返回空字符串。<br>如果c2里字符重复，按首次位置为替换依据</p>
<h2 id="Case-when"><a href="#Case-when" class="headerlink" title="Case when"></a>Case when</h2><ol>
<li><p>翻译</p>
</li>
<li><p>行转列</p>
</li>
<li><p>判断输出</p>
</li>
<li><p>简单Case函数</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">case</span> deptno</span><br><span class="line">		<span class="keyword">when</span> <span class="number">10</span> <span class="keyword">then</span> <span class="string">&#x27;第一部门&#x27;</span></span><br><span class="line">		<span class="keyword">when</span> <span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;第二部门&#x27;</span></span><br><span class="line">		<span class="keyword">when</span> <span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;第三部门&#x27;</span></span><br><span class="line">			<span class="keyword">else</span> <span class="string">&#x27;第四部门&#x27;</span></span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Case搜索函数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> deptno<span class="operator">=</span><span class="number">10</span> <span class="keyword">then</span> <span class="string">&#x27;第一部门&#x27;</span></span><br><span class="line">	 <span class="keyword">when</span> deptno<span class="operator">=</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;第二部门&#x27;</span></span><br><span class="line">	 <span class="keyword">when</span> deptno<span class="operator">=</span><span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;第三部门&#x27;</span></span><br><span class="line">			<span class="keyword">else</span> <span class="string">&#x27;第四部门&#x27;</span></span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">Case</span>函数只返回第一个符合条件的值，剩下的<span class="keyword">Case</span>部分将会被自动忽略。<span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>*<strong>Case when 生成的列也可以丢到group by 后面去分组的,where,having都可以使用CASE表达式需注意的点</strong></p>
</li>
<li><p>&#x3D;&#x3D;Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。&#x3D;&#x3D;</p>
</li>
</ol>
<h2 id="decode-等值翻译"><a href="#decode-等值翻译" class="headerlink" title="decode 等值翻译"></a>decode 等值翻译</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,deptno,</span><br><span class="line">decode(deptno,<span class="number">10</span>,<span class="string">&#x27;十号部门&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;二十号部门&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;三十号部门&#x27;</span>,<span class="string">&#x27;其他部门&#x27;</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h2 id="decode与case-when-的比较"><a href="#decode与case-when-的比较" class="headerlink" title="decode与case when 的比较"></a>decode与case when 的比较</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">Oracle</th>
<th align="center">SQL Server</th>
<th align="center">MySQL</th>
<th align="center">informix</th>
</tr>
</thead>
<tbody><tr>
<td align="center">decode支持</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">case when支持</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<ol>
<li><strong>decode 只能用做相等判断，但是可以配合sign函数进行大于，小于，等于的判断</strong></li>
<li><strong>CASE when可用于&#x3D;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&lt;&gt;,is null,is not null 等的判断；</strong></li>
</ol>
<h2 id="聚合case实现行转列"><a href="#聚合case实现行转列" class="headerlink" title="聚合case实现行转列"></a><strong>聚合</strong>case实现行转列</h2><ol>
<li>行转列方法一</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,</span><br><span class="line"><span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">then</span> sal <span class="keyword">end</span>) salesman,</span><br><span class="line"><span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span> <span class="keyword">then</span> sal <span class="keyword">end</span>) manager,</span><br><span class="line"><span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> job<span class="operator">=</span><span class="string">&#x27;CLERK&#x27;</span> <span class="keyword">then</span> sal <span class="keyword">end</span>) clerk</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br></pre></td></tr></table></figure>





<h2 id="行转列-列转行-函数"><a href="#行转列-列转行-函数" class="headerlink" title="行转列 列转行 函数"></a>行转列 列转行 函数</h2><p><strong>pivot格式</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> （数据查询集）</span><br><span class="line">PIVOT</span><br><span class="line">(</span><br><span class="line"><span class="built_in">SUM</span>(Score<span class="operator">/</span>行转列后 列的值<span class="operator">/</span>) <span class="keyword">FOR</span></span><br><span class="line">coursename<span class="operator">/</span>需要行转列的列<span class="operator">/</span> <span class="keyword">IN</span> (转换后列的值)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>行转列方法二</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> deptno,job,sal <span class="keyword">from</span> emp)</span><br><span class="line">pivot</span><br><span class="line">(</span><br><span class="line"><span class="built_in">max</span>(sal) <span class="keyword">for</span> job <span class="keyword">in</span> (<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">--行转列 列转行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> deptno,job,sal <span class="keyword">from</span> emp)</span><br><span class="line">pivot</span><br><span class="line">(</span><br><span class="line"><span class="built_in">max</span>(sal) <span class="keyword">for</span> job <span class="keyword">in</span> (<span class="string">&#x27;SALESMAN&#x27;</span> salesman,<span class="string">&#x27;MANAGER&#x27;</span> manager,<span class="string">&#x27;CLERK&#x27;</span> clerk)</span><br><span class="line">)</span><br><span class="line">unpivot</span><br><span class="line">(</span><br><span class="line">newsal <span class="keyword">for</span> job <span class="keyword">in</span>(salesman,manager,clerk)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<h2 id="开窗函数over"><a href="#开窗函数over" class="headerlink" title="开窗函数over()"></a><strong>开窗函数</strong>over()</h2><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a><strong>窗口函数</strong></h3><p>（分析函数）（主要做排序）</p>
<p>开窗函数格式： 函数名(列) OVER(选项)</p>
<p><strong>over(partition by 分组列 order by 排序列)</strong></p>
<p><code>注：order by后面可以是处理后的列</code></p>
<p>over 关键字表示把函数当成开窗函数而不是聚合函数。SQL 标准允许将所有聚合函数用做开窗函数，&#x3D;&#x3D;使用 over 关键字来区分这两种用法。&#x3D;&#x3D;</p>
<h3 id="ROW-NUMBER"><a href="#ROW-NUMBER" class="headerlink" title="ROW_NUMBER()"></a>ROW_NUMBER()</h3><p>ROW_NUMBER()函数作用就是将select查询到的数据进行排序，每一条数据加一个序号。排序的序号和rownum伪列相同，连续序号，不考虑值相等的情况（值相同序号不相同）</p>
<h3 id="RANK-–并列跳号"><a href="#RANK-–并列跳号" class="headerlink" title="RANK()–并列跳号"></a>RANK()–并列跳号</h3><p>RANK()函数，顾名思义排名函数，可以对某一个字段进行排名，可以用来做排序，<strong>它序号不连续</strong>，考虑重复数据，<strong>如果值相等序号相同</strong></p>
<h3 id="DENSE-RANK-–并列不跳号"><a href="#DENSE-RANK-–并列不跳号" class="headerlink" title="DENSE_RANK()–并列不跳号"></a>DENSE_RANK()–并列不跳号</h3><p>DENSE_RANK()密集的排名，紧密排序，可以用来做排序，它序号连续，考虑重复数据，如果值相等序号就相同他和RANK()区别在于，排名的连续性，<strong>DENSE_RANK()排名是连续的，RANK()是跳跃的排名</strong></p>
<h3 id="用聚合函数来开窗"><a href="#用聚合函数来开窗" class="headerlink" title="用聚合函数来开窗"></a><strong>用聚合函数来开窗</strong></h3><p>avg() max() count() sum() min()</p>
<p>可以不加任何条件，如果加order by 则是按照顺序依次进行计算，一般不加order by</p>
<h3 id="wm-concat函数"><a href="#wm-concat函数" class="headerlink" title="wm_concat函数"></a><strong>wm_concat</strong>函数</h3><p>wm_concat(列名),该函数可以把列值以”,”号分隔起来,并显示成一行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wm_concat(ename) <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>

<h3 id="listagg函数"><a href="#listagg函数" class="headerlink" title="listagg函数"></a><strong>listagg</strong>函数</h3><p>LISTAGG 将多行合并成一行</p>
<ol>
<li>作为普通函数，对工资进行排序，用逗号进行拼接。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">listagg</span>(ename,<span class="string">&#x27;,&#x27;</span>)<span class="keyword">within</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> sal)name <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>作为分组函数：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">listagg</span>(ename,<span class="string">&#x27;,&#x27;</span>)<span class="keyword">within</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> sal)name <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>作为分析函数：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,ename,sal,<span class="built_in">listagg</span>(ename,<span class="string">&#x27;,&#x27;</span>)<span class="keyword">within</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> sal)<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span></span><br><span class="line">   deptno)name <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>listagg()里面的order by语法是必带的，搭配开窗，开窗里的order by 不用带</p>
<h3 id="偏移分析函数"><a href="#偏移分析函数" class="headerlink" title="偏移分析函数"></a><strong>偏移分析函数</strong></h3><p><strong>lead(params,m,n) 以params为目标向下m位取数，当取不到时默认为 n</strong></p>
<p><strong>lag(params,m,n) 以params为目标向上m位取数，当取不到时默认为 n</strong></p>
<p>例如：lead(field, num, defaultvalue) field需要查找的字段，num往后查找的num行的数据，defaultvalue没有符合条件的默认值。</p>
<h2 id="group-by-和partition-by"><a href="#group-by-和partition-by" class="headerlink" title="group by 和partition by"></a>group by 和partition by</h2><p>在 SQL 中，<code>PARTITION BY</code> 和 <code>GROUP BY</code> 都用于对数据进行分组，但它们的 <strong>核心目的</strong>、<strong>使用场景</strong> 和 <strong>结果形态</strong> 有本质区别。</p>
<h3 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h3><table>
<thead>
<tr>
<th align="left"><strong><code>GROUP BY</code></strong></th>
<th align="left"><strong><code>PARTITION BY</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">对数据进行 <strong>聚合分组</strong>，生成汇总结果（每个分组返回一行）。</td>
<td align="left">对数据进行 <strong>分区</strong>，定义窗口函数的计算范围（不减少行数）。</td>
</tr>
<tr>
<td align="left">常与聚合函数（<code>SUM</code>, <code>AVG</code>, <code>COUNT</code>）结合使用。</td>
<td align="left">常与窗口函数（<code>ROW_NUMBER</code>, <code>RANK</code>, <code>SUM OVER</code>）结合使用。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-结果集形态"><a href="#2-结果集形态" class="headerlink" title="2. 结果集形态"></a><strong>2. 结果集形态</strong></h3><table>
<thead>
<tr>
<th align="left"><strong><code>GROUP BY</code></strong></th>
<th align="left"><strong><code>PARTITION BY</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">结果集中的行数 <strong>减少</strong>，每个分组返回一行。</td>
<td align="left">结果集中的行数 <strong>不变</strong>，原始数据行全部保留。</td>
</tr>
<tr>
<td align="left"><strong>示例</strong>：按部门分组统计总工资，每个部门一行。</td>
<td align="left"><strong>示例</strong>：按部门分区，计算每个员工的部门内工资排名。</td>
</tr>
</tbody></table>
<hr>
<ol>
<li><p>&#x3D;&#x3D;group by有去重效果&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;partition by没有去重效果&#x3D;&#x3D;</p>
<p>求每个部门最高工资的人员信息，max()函数少用，不止一个工资最高也可能存在其他漏洞</p>
</li>
</ol>
<h3 id="3-语法与使用场景"><a href="#3-语法与使用场景" class="headerlink" title="3. 语法与使用场景"></a><strong>3. 语法与使用场景</strong></h3><h4 id="1-GROUP-BY"><a href="#1-GROUP-BY" class="headerlink" title="(1) GROUP BY"></a><strong>(1) <code>GROUP BY</code></strong></h4><ul>
<li><p><strong>语法</strong>：配合聚合函数，生成汇总统计结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> department, <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> total_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;  <span class="comment">-- 每个部门返回一行汇总数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果示例</strong>：</p>
<table>
<thead>
<tr>
<th align="left">department</th>
<th align="left">total_salary</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HR</td>
<td align="left">250000</td>
</tr>
<tr>
<td align="left">IT</td>
<td align="left">380000</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="2-PARTITION-BY"><a href="#2-PARTITION-BY" class="headerlink" title="(2) PARTITION BY"></a><strong>(2) <code>PARTITION BY</code></strong></h4><ul>
<li><p><strong>语法</strong>：在窗口函数中定义数据分区范围，保留所有原始行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id, </span><br><span class="line">  department, </span><br><span class="line">  salary,</span><br><span class="line">  <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> dept_rank</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果示例</strong>：</p>
<table>
<thead>
<tr>
<th align="left">employee_id</th>
<th align="left">department</th>
<th align="left">salary</th>
<th align="left">dept_rank</th>
</tr>
</thead>
<tbody><tr>
<td align="left">101</td>
<td align="left">HR</td>
<td align="left">80000</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">102</td>
<td align="left">HR</td>
<td align="left">75000</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">IT</td>
<td align="left">95000</td>
<td align="left">1</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="4-关键区别总结"><a href="#4-关键区别总结" class="headerlink" title="4. 关键区别总结"></a><strong>4. 关键区别总结</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong><code>GROUP BY</code></strong></th>
<th align="left"><strong><code>PARTITION BY</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>行数变化</strong></td>
<td align="left">减少（每个分组一行）</td>
<td align="left">不变（保留所有原始行）</td>
</tr>
<tr>
<td align="left"><strong>函数类型</strong></td>
<td align="left">聚合函数（<code>SUM</code>, <code>AVG</code>）</td>
<td align="left">窗口函数（<code>RANK</code>, <code>ROW_NUMBER</code>）</td>
</tr>
<tr>
<td align="left"><strong>结果内容</strong></td>
<td align="left">分组键 + 聚合值</td>
<td align="left">原始数据 + 窗口计算结果</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">生成汇总统计报表</td>
<td align="left">排名、累计值、前后行对比分析</td>
</tr>
</tbody></table>
<h3 id="5-如何选择？"><a href="#5-如何选择？" class="headerlink" title="5. 如何选择？"></a><strong>5. 如何选择？</strong></h3><ul>
<li>**用 <code>GROUP BY</code>**：<br>需要生成汇总统计结果（如部门总工资、订单总数），且不需要保留原始明细数据。</li>
<li>**用 <code>PARTITION BY</code>**：<br>需要在保留所有原始行的基础上，添加分组计算列（如部门内排名、累计销售额）。</li>
</ul>
<hr>
<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a><strong>一句话总结</strong></h3><ul>
<li><code>GROUP BY</code> 是 <strong>纵向压缩</strong>（聚合分组，减少行数）。</li>
<li><code>PARTITION BY</code> 是 <strong>横向扩展</strong>（分区计算，保留所有行）。</li>
</ul>
<h1 id="子查询、联合查询"><a href="#子查询、联合查询" class="headerlink" title="子查询、联合查询"></a><strong>子查询、联合查询</strong></h1><h2 id="子查询-最好加别名"><a href="#子查询-最好加别名" class="headerlink" title="子查询(最好加别名)"></a>子查询(最好加别名)</h2><p>&#x3D;&#x3D;子查询就是嵌套在查询中的查询。&#x3D;&#x3D;</p>
<p>很多时候，我们对数据的查询处理不是一个查询语句就可以完成的；</p>
<p>不能完成的原因，可能是查询条件比较复杂，也可能是受困于SQL自身语法的限制；</p>
<h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a><strong>单行子查询</strong></h3><p><strong>单行子查询是指返回一行数据的子查询语句。</strong>当where子句引用单行子查询时，可以使用比较运算符（&#x3D; 、&gt;、&lt;等）。</p>
<p>查询结果表现形式：单行单列 多行单列 多行多列 单行多列</p>
<p>​				   单行单列，一个值 一个列 一个表</p>
<h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a><strong>多行子查询</strong></h3><p>多行子查询<strong>是指返回多行数据的子查询语句。</strong>当where子句引用多行子查询时，必须使用多行比较符（in、any、all、exist等）</p>
<p>查询结果表现形式:多行单列 一个列 一个表</p>
<p>例子：</p>
<p>多条件查询，大多数可以使用开窗代替</p>
<p>查看每个部门工资最高的员工姓名和他的工资</p>
<p>开窗的做法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> ename,sal,deptno,<span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) r <span class="keyword">from</span> emp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> r<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>多条件多行操作</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>ename,sal,deptno from emp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where (deptno,sal) in (select deptno,max(sal) from emp group by deptno)</span><br></pre></td></tr></table></figure>

<ul>
<li>多行多列 单行多列 一个表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal,<span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> ename,sal,<span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) paiming <span class="keyword">from</span> emp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> paiming<span class="operator">&lt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a><strong>联合查询</strong></h2><p>SQL联合查询主要是涉及两个表或者多个表（自身表多次）的查询。</p>
<p>主要分为连接查询和集合查询两大类，其中，</p>
<p><strong>连接查询</strong>分：</p>
<ul>
<li><p>内连接（inner Join 或 Join）</p>
</li>
<li><p>左外连接（left outer Join 或 left Join）</p>
</li>
<li><p>右外连接（right outer Join 或 right Join）</p>
</li>
<li><p>全外连接（full outer Join 或 full Join）</p>
</li>
</ul>
<p><strong>集合查询</strong>分:</p>
<ul>
<li><p>minus（差集）</p>
</li>
<li><p>intersect（交集）</p>
</li>
<li><p>union （并集）排序去重</p>
</li>
<li><p>union all（并集）不排序去重</p>
</li>
</ul>
<h2 id="连接查询（JOIN）"><a href="#连接查询（JOIN）" class="headerlink" title="连接查询（JOIN）"></a>连接查询（JOIN）</h2><ul>
<li><p>inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。</p>
</li>
<li><p>left join （左连接，左外连接）：返回包括左表中的所有记录和右表中连接字段相等的记录，如果没有匹配上，以null值代表右边表的列。</p>
</li>
<li><p>right join （右连接，右外连接）：返回包括右表中的所有记录和左表中连接字段相等的记录，如果没有匹配，以null值代表左边表的列</p>
</li>
<li><p>full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录，没有匹配上，以null值代表左右边表的列。</p>
</li>
</ul>
<p><img src="/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/image-20250509164008543.png" alt="image-20250509164008543"></p>
<p><img src="/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/image-20250509164028422.png" alt="image-20250509164028422"></p>
<h3 id="笛卡尔连接-交叉连接-："><a href="#笛卡尔连接-交叉连接-：" class="headerlink" title="笛卡尔连接(交叉连接)："></a>笛卡尔连接(交叉连接)：</h3><p>把笛卡尔积所有的结果给显示出来了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">cross</span> <span class="keyword">join</span> B</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">cross</span> <span class="keyword">join</span> dept;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept;</span><br></pre></td></tr></table></figure>



<p><strong>交叉连接的左外右外写法(+)写在左边就是右外，写在右边就是左外</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno(<span class="operator">+</span>)	</span><br></pre></td></tr></table></figure>



<h3 id="自然连接：一种特殊的内连接"><a href="#自然连接：一种特殊的内连接" class="headerlink" title="自然连接：一种特殊的内连接"></a>自然连接：一种特殊的内连接</h3><p>没有链接条件on，如果两个表里面有一列相等，<strong>系统默认把这一列作为链接条件，并且把这两列合成一列放到表的最面</strong>,适用于知道表里面有这样一列，并且要用这一列的时候</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">natural</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">using</span>:跟自然连接作用相同，不同在于它，当有多个列相同时，可以指定用哪一列来做链接</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">join</span> dept <span class="keyword">using</span>(deptno)</span><br></pre></td></tr></table></figure>

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>–查询出每个员工的上级领导(查询内容：员工编号、员工姓名、领导编号、领导姓名)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> yg.empno,yg.ename,ld.empno,ld.ename</span><br><span class="line"><span class="keyword">from</span> emp yg <span class="keyword">inner</span> <span class="keyword">join</span> emp ld <span class="keyword">on</span> yg.mgr<span class="operator">=</span>ld.empno</span><br></pre></td></tr></table></figure>



<h3 id="不等值连接：（过滤条件的符号不是等号）"><a href="#不等值连接：（过滤条件的符号不是等号）" class="headerlink" title="不等值连接：（过滤条件的符号不是等号）"></a>不等值连接：（过滤条件的符号不是等号）</h3><p>–查询员工的工资级别</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,grade,sal <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salgrade <span class="keyword">on</span> emp.sal <span class="keyword">between</span> losal <span class="keyword">and</span> hisal</span><br></pre></td></tr></table></figure>

<h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> yg.empno,yg.ename,ld.empno,ld.ename,dname</span><br><span class="line"><span class="keyword">from</span> emp yg <span class="keyword">inner</span> <span class="keyword">join</span> emp ld <span class="keyword">on</span> yg.mgr<span class="operator">=</span>ld.empno</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> ld.deptno<span class="operator">=</span>dept.deptno</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br></pre></td></tr></table></figure>



<p>–筛选出来emp表中不满足条件的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="keyword">where</span> dept.deptno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>–筛选出DEPT表中不满足条件数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span>d.deptno</span><br><span class="line"><span class="keyword">where</span> e.deptno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>–筛选出emp和dept表中不满足条件的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">full</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span>d.deptno</span><br><span class="line"><span class="keyword">where</span> d.deptno <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> e.deptno <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>



<h3 id="on和where使用区别"><a href="#on和where使用区别" class="headerlink" title="on和where使用区别"></a><strong>on</strong>和<strong>where</strong>使用区别</h3><p>内连接无差别，外连接用on效率高</p>
<h4 id="1-ON-的作用"><a href="#1-ON-的作用" class="headerlink" title="1. ON 的作用"></a><strong>1. <code>ON</code> 的作用</strong></h4><ul>
<li><p><strong>应用场景</strong>：专门用于 <strong><code>JOIN</code> 操作</strong>（如 <code>INNER JOIN</code>、<code>LEFT JOIN</code> 等）。</p>
</li>
<li><p><strong>作用时机</strong>：在 <strong>表连接过程中</strong> 定义连接条件。</p>
</li>
<li><p><strong>核心逻辑</strong>：</p>
<ul>
<li><p>决定两张表的行如何匹配。</p>
</li>
<li><p>如果条件不满足，<strong>仍可能保留主表的行</strong>（取决于 <code>JOIN</code> 类型）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-WHERE-的作用"><a href="#2-WHERE-的作用" class="headerlink" title="2. WHERE 的作用"></a><strong>2. <code>WHERE</code> 的作用</strong></h4><ul>
<li><strong>应用场景</strong>：用于 <strong>最终结果集的全局过滤</strong>。</li>
<li><strong>作用时机</strong>：在 <strong>所有表连接完成后</strong> 筛选数据。</li>
<li><strong>核心逻辑</strong>：<ul>
<li>过滤掉不满足条件的行。</li>
<li>如果条件不满足，<strong>直接丢弃整行数据</strong>。</li>
</ul>
</li>
</ul>
<h4 id="3-关键区别总结"><a href="#3-关键区别总结" class="headerlink" title="3. 关键区别总结"></a><strong>3. 关键区别总结</strong></h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ON</code></th>
<th align="left"><code>WHERE</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用阶段</strong></td>
<td align="left">表连接过程中</td>
<td align="left">表连接完成后</td>
</tr>
<tr>
<td align="left"><strong>影响范围</strong></td>
<td align="left">定义表之间的匹配规则</td>
<td align="left">全局过滤结果集</td>
</tr>
<tr>
<td align="left"><strong>保留主表数据</strong></td>
<td align="left">是（如 <code>LEFT JOIN</code>）</td>
<td align="left">否（不满足条件则丢弃所有行）</td>
</tr>
<tr>
<td align="left"><strong>性能影响</strong></td>
<td align="left">可能减少连接的数据量</td>
<td align="left">对最终结果过滤</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">指定连接条件</td>
<td align="left">筛选最终结果</td>
</tr>
</tbody></table>
<h4 id="4-不同-JOIN-类型下的行为"><a href="#4-不同-JOIN-类型下的行为" class="headerlink" title="4. 不同 JOIN 类型下的行为"></a><strong>4. 不同 <code>JOIN</code> 类型下的行为</strong></h4><p><strong>场景：左表有数据，右表无匹配</strong></p>
<ul>
<li><strong><code>LEFT JOIN</code> + <code>ON</code> 条件不满足</strong><ul>
<li>左表行保留，右表字段填充 <code>NULL</code>。</li>
</ul>
</li>
<li><strong><code>LEFT JOIN</code> + <code>WHERE</code> 条件不满足</strong><ul>
<li>整行被丢弃。</li>
</ul>
</li>
</ul>
<h4 id="5-何时用-ON-或-WHERE？"><a href="#5-何时用-ON-或-WHERE？" class="headerlink" title="5. 何时用 ON 或 WHERE？"></a><strong>5. 何时用 <code>ON</code> 或 <code>WHERE</code>？</strong></h4><ul>
<li>**用 <code>ON</code>**：<ul>
<li>定义表之间的连接逻辑。</li>
<li>在 <code>JOIN</code> 过程中过滤右表数据（同时保留主表数据）。</li>
</ul>
</li>
<li>**用 <code>WHERE</code>**：<ul>
<li>对最终结果集进行全局过滤。</li>
<li>需要严格筛选所有行时。</li>
</ul>
</li>
</ul>
<h4 id="6-一句话总结"><a href="#6-一句话总结" class="headerlink" title="6. 一句话总结"></a><strong>6. 一句话总结</strong></h4><ul>
<li><strong><code>ON</code> 决定如何连接表</strong>，<code>WHERE</code> 决定最终显示什么。</li>
<li>在 <code>LEFT JOIN</code> 中，若希望保留主表数据，右表的过滤条件应写在 <code>ON</code> 中；若想严格过滤结果，则用 <code>WHERE</code>。</li>
</ul>
<h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a><strong>集合查询</strong></h2><ol>
<li><p>集合查询后的结果字段名<strong>显示为第一条select语句字段名</strong></p>
</li>
<li><p>union&#x2F;union all,intersect 没有上下关系，minus有<strong>（永远是上减下）</strong></p>
</li>
<li><p>集合做运算的时候，可以不仅是一列，多列做运算时，要求列数量相等，并且列的数据类型相同</p>
</li>
<li><p>union、union all、intersect、minus运算可以进行混合运算、它们之间优先级相同。</p>
</li>
<li><p>可以使用圆括号控制集合运算的优先级，它具有最高的优先级</p>
</li>
<li><p><strong>union拼接后结果排序，去重，union all ，不排序，不去重，union all 效率更高</strong></p>
</li>
</ol>
<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> dept</span><br></pre></td></tr></table></figure>

<h4 id="union-all-并集全部显示"><a href="#union-all-并集全部显示" class="headerlink" title="union all 并集全部显示"></a>union all 并集全部显示</h4><p>（列名可以不一样，类型一样就可以了）要</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>

<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> dept</span><br></pre></td></tr></table></figure>

<h4 id="差集minus"><a href="#差集minus" class="headerlink" title="差集minus"></a>差集minus</h4><p><strong>永远都是上减下</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> dept</span><br><span class="line">minus</span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line">(<span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> dept)</span><br><span class="line">minus</span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>



<h4 id="灵活应用"><a href="#灵活应用" class="headerlink" title="灵活应用"></a>灵活应用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empno,ename <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">333</span>,<span class="string">&#x27;test&#x27;</span> <span class="keyword">from</span> dual</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> empno <span class="keyword">desc</span>; </span><br></pre></td></tr></table></figure>

<h1 id="exits-和-exit"><a href="#exits-和-exit" class="headerlink" title="exits 和 exit"></a>exits 和 exit</h1><h3 id="一、EXIT：退出流程控制"><a href="#一、EXIT：退出流程控制" class="headerlink" title="一、EXIT：退出流程控制"></a><strong>一、<code>EXIT</code>：退出流程控制</strong></h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>主要用于 <strong>PL&#x2F;SQL</strong>（Oracle 的过程化 SQL）中，控制循环或代码块的执行流程。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul>
<li><strong>终止循环</strong>：立即退出 <code>LOOP</code>、<code>WHILE</code> 或 <code>FOR</code> 循环。</li>
<li><strong>退出代码块</strong>：在特定条件下提前结束程序执行。</li>
</ul>
<h4 id="语法示例"><a href="#语法示例" class="headerlink" title="*语法示例"></a>*<em>语法示例</em></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span><span class="number">.10</span> LOOP</span><br><span class="line">    EXIT <span class="keyword">WHEN</span> i <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">-- 当 i=5 时退出循环</span></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(i);</span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、EXISTS：存在性检查"><a href="#二、EXISTS：存在性检查" class="headerlink" title="二、EXISTS：存在性检查"></a><strong>二、<code>EXISTS</code>：存在性检查</strong></h3><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><p>用于 <strong>SQL 查询</strong> 中，检查子查询是否返回至少一行数据。</p>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul>
<li><strong>条件过滤</strong>：结合 <code>WHERE</code> 子句，判断子查询是否有结果。</li>
<li><strong>高效验证</strong>：子查询一旦找到匹配记录即终止扫描，性能优于 <code>IN</code> 或 <code>JOIN</code>。</li>
</ul>
<h4 id="语法示例-1"><a href="#语法示例-1" class="headerlink" title="语法示例"></a><strong>语法示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询有订单的客户</span><br><span class="line">SELECT customer_id, name</span><br><span class="line">FROM customers c</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">  SELECT 1</span><br><span class="line">  FROM orders o</span><br><span class="line">  WHERE o.customer_id = c.customer_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：仅返回至少有一个订单的客户。</p>
<hr>
<h3 id="三、核心区别总结"><a href="#三、核心区别总结" class="headerlink" title="三、核心区别总结"></a><strong>三、核心区别总结</strong></h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>EXIT</code></th>
<th align="left"><code>EXISTS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">控制流程（退出循环&#x2F;代码块）</td>
<td align="left">检查子查询是否存在结果</td>
</tr>
<tr>
<td align="left"><strong>语境</strong></td>
<td align="left">PL&#x2F;SQL 编程</td>
<td align="left">SQL 查询</td>
</tr>
<tr>
<td align="left"><strong>执行逻辑</strong></td>
<td align="left">终止当前循环或代码块</td>
<td align="left">快速验证子查询是否返回数据</td>
</tr>
<tr>
<td align="left"><strong>常见场景</strong></td>
<td align="left">循环中的条件终止</td>
<td align="left">筛选关联数据、优化复杂查询</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、常见误区"><a href="#四、常见误区" class="headerlink" title="四、常见误区"></a><strong>四、常见误区</strong></h3><h4 id="1-误将-EXIT-用于-SQL-查询"><a href="#1-误将-EXIT-用于-SQL-查询" class="headerlink" title="1. 误将 EXIT 用于 SQL 查询"></a>1. <strong>误将 <code>EXIT</code> 用于 SQL 查询</strong></h4><ul>
<li><code>EXIT</code> 是 PL&#x2F;SQL 的关键字，<strong>不能直接在纯 SQL 语句中使用</strong>（如 <code>SELECT</code> 查询）。</li>
</ul>
<h4 id="2-混淆-EXISTS-和-IN"><a href="#2-混淆-EXISTS-和-IN" class="headerlink" title="2. 混淆 EXISTS 和 IN"></a>2. <strong>混淆 <code>EXISTS</code> 和 <code>IN</code></strong></h4><ul>
<li><code>EXISTS</code> 关注子查询是否有结果，而 <code>IN</code> 用于匹配具体值列表。</li>
<li><strong>性能差异</strong>：<code>EXISTS</code> 通常比 <code>IN</code> 高效，尤其是子查询数据量大时。</li>
</ul>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><ul>
<li><p><strong><code>EXIT</code></strong> 是 PL&#x2F;SQL 的流程控制工具，用于终止循环或代码块。</p>
</li>
<li><p><strong><code>EXISTS</code></strong> 是 SQL 的逻辑运算符，用于高效验证子查询是否存在数据。</p>
</li>
</ul>
<h3 id="exists和in的区别"><a href="#exists和in的区别" class="headerlink" title="exists和in的区别"></a><strong>exists</strong>和<strong>in</strong>的区别</h3><p>  IN适合于外表大而内表小的情况;EXISTS适合于外表小而内表大的情况,这样效率会高的。</p>
<h4 id="带索引分析exists和in的区别"><a href="#带索引分析exists和in的区别" class="headerlink" title="带索引分析exists和in的区别"></a><em>带索引分析exists和</em>in的区别</h4><pre><code> in是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询，一直以来认为exists比in效率高的说法是不准确的。如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in；
</code></pre>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>​	正如所看到的，not in出现了不期望的结果集，存在逻辑错误，所以，请尽量不要使用not in(它会调用子查询)，而尽量使用not exists（它会调用关联子查询）。<strong>如果子查询中返回的任意一条记录含有空值，则查询将不返回任何记录。</strong>如果子查询字段有非空限制，这时可以使用not in。<strong>如果查询语句使用了not in，那么对内外表都进行全表扫描，没有用到索引；而notexists的子查询依然能用到表上的索引。</strong>所以无论哪个表大，用not exists都比not in 要快。</p>
<h1 id="2种批量插入方式"><a href="#2种批量插入方式" class="headerlink" title="2种批量插入方式"></a>2种批量插入方式</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ol>
<li>执行创表语句，如下：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> shuiguo <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>点击开锁，鼠标图标向右，右滑全选中全蓝色，选择需要负责的数据，到工具里面粘贴，打钩√。</li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol>
<li>工具-&gt;ODBC导入器-&gt;填用&#x2F;系统Excel Files-&gt;连接-&gt;填写路径并选择文件-&gt;选择插入的表-&gt;选择完说有字段并设置格式-&gt;导入</li>
</ol>
<h1 id="定义操作控制等语句"><a href="#定义操作控制等语句" class="headerlink" title="定义操作控制等语句"></a><strong>定义操作控制等语句</strong></h1><h2 id="索引视图序列"><a href="#索引视图序列" class="headerlink" title="索引视图序列"></a><strong>索引视图序列</strong></h2><p>在对包含很多行的表进行检索其中几行数据时，都应该创建索引，以加快检索速度。</p>
<ol>
<li><p>索引是数据库对象之一，<strong>用于加快数据的检索</strong>，类似于书籍的索引。在数据库中索引<strong>可以减少数据库程序查询结果时需要读取的数据量</strong>，类似于在书籍中我们利用索引可以不用翻阅整本书即可找到想要的信息。</p>
</li>
<li><p><strong>索引是建立在表上的可选对象</strong>；索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式，从而提高检索效率</p>
</li>
<li><p>索引在逻辑上和物理上都与相关的表和数据无关，当创建或者删除一个索引时，不会影响基本的表；</p>
</li>
<li><p>索引<strong>一旦建立，会自动管理索引</strong>，索引删除，不会对表产生影响</p>
</li>
<li><p>oracle创建主键时会<strong>自动</strong>在该列上创建索引</p>
</li>
</ol>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a><strong>索引的分类</strong></h3><h4 id="一、按存储形式（即索引中存储的内容不同）"><a href="#一、按存储形式（即索引中存储的内容不同）" class="headerlink" title="一、按存储形式（即索引中存储的内容不同）"></a><strong>一、按存储形式（即索引中存储的内容不同）</strong></h4><ol>
<li><p>B-TREE索引(索引列原始数据+ROWID)</p>
</li>
<li><p>位图索引(位图+ROWID)</p>
</li>
<li><p>反向键索引(索引列原始数据的反向存储+ROWID)</p>
</li>
<li><p>基于函数的索引(将索引列原始数据经函数处理后存储+ROWID)</p>
</li>
</ol>
<p>索引的命名规范：IND_TBNAME_COLNAME</p>
<table>
<thead>
<tr>
<th></th>
<th>B-TREE索引</th>
<th>位图索引</th>
<th>反向键索引</th>
<th>基于函数的索引</th>
</tr>
</thead>
<tbody><tr>
<td>说明</td>
<td>ORACLE的<strong>默认索引类</strong>型，工作中最常见、使用范围最广的索引</td>
<td>位图索引在创建时，会扫描整张表，为索引列的每个取值建立一个<strong>不重复的位图（</strong>BITMAP）来描述该取值</td>
<td>可以视作一种特殊的B-TREE索引，<strong>存储索引列的反向值</strong></td>
<td>可以视作一种特殊的B-TREE索引，<strong>存储函数处理后的数据</strong></td>
</tr>
<tr>
<td>语法</td>
<td><strong>create</strong> <strong>index</strong> ind_name <strong>on</strong> TB_NAME(COL_NAME);</td>
<td><strong>CREATE</strong> <strong>BITMAP</strong> <strong>INDEX</strong> IND_NAME <strong>ON</strong> TB_NAME(COL_NAME);</td>
<td><strong>CREATE INDEX</strong> IND_NAME <strong>ON</strong> TB_NAME(COL_NAME) <strong>REVERSE</strong>;</td>
<td><strong>CREATE INDEX</strong> IND_NAME <strong>ON</strong> TB_NAME(<strong>FUNCTION</strong>(COL_NAME));</td>
</tr>
<tr>
<td>背景</td>
<td><strong>列基数比较大</strong>的时候使用（行业、身高）</td>
<td><strong>列基数比较小</strong>的时候使用（性别、婚姻状况）</td>
<td>为防止B-TREE索引在某叶上<strong>数据量占比过高</strong>而使用的一种索引</td>
<td>在某个字段上以原值建立了索引，但是在筛选时在该字段上<strong>经常加函数，导致索引无法生效</strong></td>
</tr>
</tbody></table>
<p><strong>二、按唯一性（索引列中的数据是否有重复值）</strong></p>
<ol>
<li><strong>唯一索引</strong> –索引列中<strong>不可能出现重复值</strong></li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX IND_NAME <span class="keyword">ON</span> TB_NAME(COL_NAME);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li><p>B-TREE索引可以建立唯一索引，位图索引不能建立唯一索引</p>
</li>
<li><p>如果在某列上建立了唯一约束或主键约束，ORACLE会自动在该列上建立一个同名的唯一索引</p>
</li>
<li><p><strong>非唯一索引</strong> –索引列中<strong>可能出现重复值</strong></p>
</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IND_NAME <span class="keyword">ON</span> TB_NAME(COL_NAME);</span><br></pre></td></tr></table></figure>

<p><strong>三、按列的个数（索引覆盖的列的个数）</strong></p>
<ol>
<li>单列索引 –基于一个列建立的索引</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IND_NAME <span class="keyword">ON</span> TB_NAME(COL_NAME);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>复合索引(也称为联合索引） –基于两个或两个以上列建立的索引</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IND_NAME <span class="keyword">ON</span> TB_NAME(COL_NAME1,COL_NAME2...);</span><br></pre></td></tr></table></figure>



<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a><strong>创建索引</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> [<span class="keyword">unique</span><span class="operator">|</span>BITMAP] index 索引名称 <span class="keyword">on</span> 表名（列名[，列名]） tablespace 表空间名；</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Unique 用于指定是否强制要求索引列为唯一性数据，表空间可选择是否指定，不指定则用默认表空间。</p>
</li>
<li><p>出于性能考虑索引表空间和表的表空间要分开。</p>
</li>
</ol>
<h3 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a><strong>修改索引</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> index 索引名 rename <span class="keyword">to</span> 新索引名；</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a><strong>删除索引</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过<span class="keyword">drop</span> index 索引名；</span><br></pre></td></tr></table></figure>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a><strong>视图</strong></h3><p>视图实际上是一个或多个表的预定义查询，视图的使用方法和表一样。视图不存储数据，他们只访问基表中的行。</p>
<p>创建视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">with</span> read <span class="keyword">only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Drop</span> <span class="keyword">view</span> 视图名；删除视图</span><br></pre></td></tr></table></figure>

<p>scott账号要使用system账号赋予权限才能创建视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">any</span> <span class="keyword">view</span> <span class="keyword">to</span> scott</span><br></pre></td></tr></table></figure>





<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p>事务：<strong>它是数据库在执行一系列操作时，保证所有的操作都正确完成，要么都执行，要么都不执行，保证数据的完整性</strong>。</p>
<p>必须具备以下四个属性，简称<strong>ACID 属性</strong>：</p>
<p>A:原子性（Atomicity）：事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</p>
<p>C:一致性（Consistency）：一个查询的结果必须与数据库在查询开始时的状态保持一致（读不等待写，写不等待读）。</p>
<p>I:隔离性（Isolation）：数据库中每一个用户的操作都是互不影响的，对于其他会话来说，未完成的（也就是未提交的）事务必须不见。</p>
<p>D:持久性（Durability）：事务一旦提交完成后，数据库就不可以丢失这个事务的结果，数据就永久的保存到数据库中。</p>
<h3 id="事务的开始和结束"><a href="#事务的开始和结束" class="headerlink" title="事务的开始和结束"></a><strong>事务的开始和结束</strong></h3><p>事务采用隐性的方式，起始于session的第一条DML语句，</p>
<p>事务结束于：</p>
<ol>
<li><p>COMMIT（提交）或ROLLBACK（回滚）</p>
</li>
<li><p>DDL语句被执行（提交）</p>
</li>
<li><p>DCL语句被执行（提交）</p>
</li>
<li><p>用户退出SQLPLUS（正常退出是提交，非正常退出是回滚）</p>
</li>
<li><p>服务器故障或系统崩溃（回滚）</p>
</li>
<li><p>shutdowm immediate(回滚）</p>
</li>
</ol>
<p>在一个事务里如果某个DML语句失败，之前其他任何DML语句将保持完好，而且不会提交！</p>
<h3 id="Oracle-的事务保存点功能"><a href="#Oracle-的事务保存点功能" class="headerlink" title="Oracle 的事务保存点功能"></a><strong>Oracle</strong> <strong>的事务保存点功能</strong></h3><p>savepoint命令允许在事务进行中设置一个标记（保存点），这个标记可以控制rollback的效果，即在一个事务中回滚掉最近的部分dml语句，保留下保存点之前的的dml语句，并使事务本身继续执行(考点）。也就是说回滚到保存点这个动作并不使事务结束。</p>
<p>commit 提交</p>
<p>rollback 回滚</p>
<p>保存点：savepoint 可以把在保存点之后的事务给撤销掉</p>
<p>操作完之后-&gt;savepoint 保存点名字</p>
<p>回退到保存点-&gt;rollback to 保存点名字</p>
<h3 id="排它锁和共享锁"><a href="#排它锁和共享锁" class="headerlink" title="排它锁和共享锁"></a>排它锁和共享锁</h3><p>数据库中两种基本类型的锁：排它锁和共享锁。当数据被上了排它锁，就不能被其他事</p>
<p>务读取和修改；而上了共享锁，只能被其他事务读取，但是不能被修改数据库。</p>
<p>update emp set sal&#x3D;sal*1.1 where deptno&#x3D;10;–行级排他锁</p>
<p>查看自己的sessionid</p>
<p>select userenv(‘sid’) from dual;</p>
<p>解决锁定冲突</p>
<ol>
<li><p>执行commit或者rollback结束事务</p>
</li>
<li><p>终止会话</p>
</li>
<li><p>管理员杀死进程</p>
</li>
</ol>
<h3 id="Oracle锁表解锁-system用户登录"><a href="#Oracle锁表解锁-system用户登录" class="headerlink" title="Oracle锁表解锁 system用户登录"></a>Oracle锁表解锁 system用户登录</h3><p>既然清楚了锁表如何形成的，那么我们就要开始解锁。解锁的方法很简单，通过Sql语句</p>
<p>就可实现。</p>
<p>1.查看被锁的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> b.owner,b.object_name,a.session_id,a.locked_mode</span><br><span class="line"><span class="keyword">From</span> v$locked_object a,dba_objects b</span><br><span class="line"><span class="keyword">Where</span> b.object_id <span class="operator">=</span> a.object_id;</span><br></pre></td></tr></table></figure>

<p>2.查看那个用户那个进程造成死锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid, q.sql_text</span><br><span class="line"><span class="keyword">FROM</span> v$sqltext q, v$session s</span><br><span class="line"><span class="keyword">WHERE</span> q.address <span class="operator">=</span> s.sql_address <span class="keyword">AND</span> s.sid <span class="operator">=</span> <span class="operator">&amp;</span>sid <span class="comment">-- 这个&amp;sid 是第一步查询出来的</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> piece;<span class="comment">--查看导致锁死的SQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span></span><br><span class="line">b.username,b.sid,b.serial#,logon_time</span><br><span class="line"><span class="keyword">From</span> v$locked_object a,v$session b</span><br><span class="line"><span class="keyword">Where</span> a.session_id <span class="operator">=</span> b.sid <span class="keyword">order</span> <span class="keyword">by</span> b.logon_time;</span><br></pre></td></tr></table></figure>

<p>3.杀掉进程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;alter system kill session &#x27;&#x27;&#x27;</span> <span class="operator">||</span> sid <span class="operator">||</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">||</span> serial# <span class="operator">||</span> <span class="string">&#x27;&#x27;&#x27;;&#x27;</span> &quot;Deadlock&quot; <span class="keyword">FROM</span> v$session</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> v$lock <span class="keyword">WHERE</span> block <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p>两个事务并发访问数据库数据时可能存在的问题</p>
<ol>
<li>幻想读：</li>
</ol>
<p>　　<strong>事务T1读取一条指定where条件的语句，返回结果集。此时事务T2插入一行新记录</strong></p>
<p><strong>并commit，恰好满足T1的where条件。然后T1使用相同的条件再次查询，结果集中可以</strong></p>
<p><strong>看到T2插入的记录，这条新纪录就是幻想。</strong></p>
<ol start="2">
<li>不可重复读取：</li>
</ol>
<p>　　事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录并commit，然后T1再</p>
<p>次查询，发现与第一次读取的记录不同，这称为不可重复读。</p>
<ol start="3">
<li>脏读：</li>
</ol>
<p>　　<strong>事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后</strong></p>
<p><strong>T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据</strong></p>
<h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a><strong>同义词</strong></h2><p>同义词：它是给数据库中的对象起一个别名，可以和使用原对象一样去使用同义词</p>
<p>同义词一般是给原对象取一个简单易记的名字，管理员system创建同义词</p>
<p>创建语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace synonym 同义词名 <span class="keyword">for</span> 对象名;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> synonym e <span class="keyword">for</span> scott.emp; <span class="comment">--给表创建同义词</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> e;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace synonym de <span class="keyword">for</span> scott.dept_emp; <span class="comment">--给视图创建同义词</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> de;</span><br></pre></td></tr></table></figure>

<p><strong>同义词可以用来做只读用户，同义词可以用来做只读用户提高安全性</strong></p>
<p>Oracle数据库中提供了同义词管理的功能。</p>
<p><strong>同义词是数据库方案对象的一个别名，经常用于简化对象访问和提高对象访问的安全性。</strong>在使用同义词时，Oracle数据库将它翻译成对应方案对象的名字。<strong>与视图类似，同义词并不占用实际存储空间</strong>，<strong>只在数据字典中保存了同义词的定义。</strong>在Oracle数据库中的大部分数据库对象，如表、视图、同义词、序列、存储过程、包等等，数据库管理员都可以根据实际情况为他们定义同义词</p>
<h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a><strong>数据字典</strong></h2><p><strong>数据库字典：是数据库自己维护一组表，它存放了用户创建的所有对象的信息。</strong></p>
<p><strong>数据库字典视图：就是数据库字典视图</strong></p>
<p><strong>dba_:管理员数据库字典视图</strong></p>
<p><strong>user_:用户的数据库字典视图</strong></p>
<p><strong>all_:所有用户都可见的数据库字典视图</strong></p>
<h2 id="数据导入导出"><a href="#数据导入导出" class="headerlink" title="数据导入导出"></a><strong>数据导入导出</strong></h2><p>数据的迁移和备份，导入导出，虚拟机cmd进行操作</p>
<p>exp 账号&#x2F;密码@数据库名 file&#x3D;文件存放路径 full&#x3D;y –全库导出，命令行语句，不需要登录数据，只需要在命令行运行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--按用户导出：</span></span><br><span class="line">exp scott<span class="operator">/</span>oracle<span class="variable">@orcl</span> file<span class="operator">=</span>c:\test\exp_0512_scott.bak OWNER<span class="operator">=</span>scott</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--导入</span></span><br><span class="line">imp scott<span class="operator">/</span>oracle<span class="variable">@orcl</span> file<span class="operator">=</span>c:\test\exp_0711_scott.bak ignore<span class="operator">=</span>y</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h1 id="with-as-子查询"><a href="#with-as-子查询" class="headerlink" title="with..as 子查询"></a><strong>with..as</strong> <strong>子查询</strong></h1><p>with..as关键字，是以‘with’关键字开头的sql语句，在实际工作中，我们经常会遇到同一个查询sql会同时查询多个相同的结果集，即sql一模一样，这时候我们可以<strong>将这些相同的sql抽取出来，使用with..as定义。with..as相当于一张中间表，可以简单理解为sql片段。</strong></p>
<p>–<strong>with as 可以理解为一张临时表或者理解成sql片段，在多次查询语句相同的时候可以抽取出来，达到’一次解析，多次使用’</strong></p>
<p>–<strong>如果每个部分都去执行一遍的话，则成本比较高，可以使用with as短语，则只要执行一遍即可</strong></p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> temp <span class="keyword">as</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) a,<span class="built_in">max</span>(deptno) m <span class="keyword">from</span> emp)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> sal<span class="operator">&lt;</span>(<span class="keyword">select</span> a <span class="keyword">from</span> temp) <span class="keyword">and</span> deptno<span class="operator">=</span>(<span class="keyword">select</span> m <span class="keyword">from</span> temp)</span><br><span class="line"></span><br><span class="line"><span class="comment">--with as 非常适合在union 语句中</span></span><br><span class="line"><span class="comment">--注意：with as 语句最后面不能加分号，否则报缺失select关键字错误。</span></span><br><span class="line"><span class="keyword">with</span> temp1 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="string">&#x27;female&#x27;</span> sex, <span class="string">&#x27;zhangsan&#x27;</span> stu_name <span class="keyword">from</span> dual),</span><br><span class="line">temp2 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="string">&#x27;male&#x27;</span> sex, <span class="string">&#x27;lisi&#x27;</span> stu_name <span class="keyword">from</span> dual),</span><br><span class="line">temp3 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="string">&#x27;female&#x27;</span> sex, <span class="string">&#x27;wangwu&#x27;</span> stu_name <span class="keyword">from</span> dual)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> temp1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> temp2</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp3</span><br><span class="line"></span><br><span class="line"><span class="comment">--前面定义的with..as语句可以在后面定义的with..as语句使用</span></span><br><span class="line"><span class="keyword">with</span> temp1 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="string">&#x27;female&#x27;</span> sex, <span class="string">&#x27;zhangsan&#x27;</span> stu_name <span class="keyword">from</span> dual),</span><br><span class="line">temp2 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="string">&#x27;male&#x27;</span> sex, <span class="string">&#x27;lisi&#x27;</span> stu_name <span class="keyword">from</span> dual),</span><br><span class="line">temp3 <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp2)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> temp1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> temp2</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp3</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://cryingatnight.github.io">Yinjin Yao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://cryingatnight.github.io/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/">https://cryingatnight.github.io/2025/04/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://cryingatnight.github.io" target="_blank">Yinjin Yao的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Oracle/">Oracle</a><a class="post-meta__tags" href="/tags/SQL/">SQL</a></div><div class="post-share"><div class="social-share" data-image="/img/%E4%BA%94%E6%9D%A1%E6%82%9F.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/16/CentOS7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="CentOS7操作系统"><img class="cover" src="/img/lita6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CentOS7操作系统</div></div><div class="info-2"><div class="info-item-1">文件目录类Linux目录结构 linux的目录有且只有一个根目录 &#x2F;  linux的各个目录存放的内容的规划好的, 不用乱放文件  linux是以文件的形式管理我们的设备, 因此linux系统, 一切皆为文件  linux的各个目录下存放什么内容, 大家必须有一个认识  学习后, 你的脑海里应该有一棵linux目录树      目录 功能 目录 功能    &#x2F; 根目录系统的起点包含所有其他目录 &#x2F;opt 可选的第三方软件   &#x2F;bin 存放基本和系统级的可执行文件 &#x2F;proc 虚拟文件系统提供系统信息   &#x2F;boot 启动相关文件 &#x2F;root root用户的主目录   &#x2F;dev 设备文件 &#x2F;run 运行时数据   &#x2F;etc 系统配置文件 &#x2F;tmp 临时文件   &#x2F;home 用户的主目录 &#x2F;usr 用户级应用程序和数据   &#x2F;lib 共享库文件 &#x2F;var 可变数据，如日志和缓存   &#x2F;mnt 挂载点     &#x2F;op...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/27/Hive/" title="Hive"><img class="cover" src="/img/lita8.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-27</div><div class="info-item-2">Hive</div></div><div class="info-2"><div class="info-item-1">什么是HIVEHive 是基于 Hadoop 的一个数据仓库工具。以下是具体介绍:  功能特点：Hive 可以将结构化的数据文件映射为一张数据库表，并提供完整的 SQL 查询功能，能将 SQL 语句转换为 MapReduce 任务进行运行。它允许熟悉 SQL 的用户方便地查询数据，也支持熟悉 MapReduce 的开发者自定义 mapper 和 reducer，以处理复杂的分析工作。 优势：学习成本低，通过类 SQL 语句可快速实现简单的 MapReduce 统计，无需开发专门的 MapReduce 应用，十分适合数据仓库的统计分析。 应用场景：常用于对时效性要求不高的数据分析场景。由于 Hive 底层依赖 Hadoop 的 HDFS 存储数据，利用 MapReduce 进行计算，因此能够处理大规模的数据，在处理海量结构化日志的数据统计等方面应用广泛。 与数据库的区别： 数据库一般用于在线应用，支持对某一行或某些行数据的更新、删除等操作，采用 “写时模式”，数据加载慢但查询快。 而 Hive 不支持对具体行的操作，也不支持事务和索引，采用 “读时模式”，适合处理非结构化或存储模式...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/headimage.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yinjin Yao</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cryingatnight/cryingatnight.github.io"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/cryingatnight/cryingatnight.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1816192779@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">什么是数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD%E5%8F%8A%E6%A6%82%E5%BF%B5%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">术语及概念简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">SQL是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">SQL分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D"><span class="toc-number">1.5.</span> <span class="toc-text">去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dual%E8%99%9A%E6%8B%9F%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">dual虚拟表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E5%88%97"><span class="toc-number">1.7.</span> <span class="toc-text">伪列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%92%8C%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">表和表空间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%A9%BA%E9%97%B4%EF%BC%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">创建临时表空间：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-number">2.2.3.</span> <span class="toc-text">创建用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%B5%8B%E4%BA%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">用户权限赋予</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.5.</span> <span class="toc-text">删除表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.6.</span> <span class="toc-text">扩容 表空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.3.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%97%E7%BA%A7%E7%BA%A6%E6%9D%9F%EF%BC%88Column-Level-Constraints%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 列级约束（Column-Level Constraints）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A1%A8%E7%BA%A7%E7%BA%A6%E6%9D%9F%EF%BC%88Table-Level-Constraints%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 表级约束（Table-Level Constraints）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E5%A4%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">六大约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="toc-number">3.</span> <span class="toc-text">操作符与增删改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#insert%E6%8F%92%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">insert插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update%E4%BF%AE%E6%94%B9"><span class="toc-number">3.2.</span> <span class="toc-text">update修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E5%88%A0%E9%99%A4"><span class="toc-number">3.3.</span> <span class="toc-text">delete删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%EF%BC%8Cdrop%EF%BC%8Ctruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">delete，drop，truncate的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge"><span class="toc-number">3.5.</span> <span class="toc-text">Merge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.6.</span> <span class="toc-text">操作符优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E3%80%81%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.</span> <span class="toc-text">排列、分组查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.1.</span> <span class="toc-text">排列查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.2.</span> <span class="toc-text">分组查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#where-%E5%92%8C-having%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.1.</span> <span class="toc-text">where 和 having的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#where%E6%9D%A1%E4%BB%B6%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%9C%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">where条件里为什么不能有聚合函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.</span> <span class="toc-text">递归查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E7%8E%AF%E6%AF%94"><span class="toc-number">6.</span> <span class="toc-text">同环比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">关键词执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">常用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.2.</span> <span class="toc-text">数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">转换函数示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E8%B5%8B%E5%80%BCnvl"><span class="toc-number">8.3.</span> <span class="toc-text">空值赋值nvl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TRANSLATE-c1-c2-c3"><span class="toc-number">8.4.</span> <span class="toc-text">TRANSLATE(c1,c2,c3)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-when"><span class="toc-number">8.5.</span> <span class="toc-text">Case when</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decode-%E7%AD%89%E5%80%BC%E7%BF%BB%E8%AF%91"><span class="toc-number">8.6.</span> <span class="toc-text">decode 等值翻译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decode%E4%B8%8Ecase-when-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.7.</span> <span class="toc-text">decode与case when 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88case%E5%AE%9E%E7%8E%B0%E8%A1%8C%E8%BD%AC%E5%88%97"><span class="toc-number">8.8.</span> <span class="toc-text">聚合case实现行转列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E8%BD%AC%E5%88%97-%E5%88%97%E8%BD%AC%E8%A1%8C-%E5%87%BD%E6%95%B0"><span class="toc-number">8.9.</span> <span class="toc-text">行转列 列转行 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0over"><span class="toc-number">8.10.</span> <span class="toc-text">开窗函数over()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">8.10.1.</span> <span class="toc-text">窗口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROW-NUMBER"><span class="toc-number">8.10.2.</span> <span class="toc-text">ROW_NUMBER()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RANK-%E2%80%93%E5%B9%B6%E5%88%97%E8%B7%B3%E5%8F%B7"><span class="toc-number">8.10.3.</span> <span class="toc-text">RANK()–并列跳号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DENSE-RANK-%E2%80%93%E5%B9%B6%E5%88%97%E4%B8%8D%E8%B7%B3%E5%8F%B7"><span class="toc-number">8.10.4.</span> <span class="toc-text">DENSE_RANK()–并列不跳号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%9D%A5%E5%BC%80%E7%AA%97"><span class="toc-number">8.10.5.</span> <span class="toc-text">用聚合函数来开窗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wm-concat%E5%87%BD%E6%95%B0"><span class="toc-number">8.10.6.</span> <span class="toc-text">wm_concat函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listagg%E5%87%BD%E6%95%B0"><span class="toc-number">8.10.7.</span> <span class="toc-text">listagg函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0"><span class="toc-number">8.10.8.</span> <span class="toc-text">偏移分析函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-by-%E5%92%8Cpartition-by"><span class="toc-number">8.11.</span> <span class="toc-text">group by 和partition by</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">8.11.1.</span> <span class="toc-text">1. 核心作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%9C%E9%9B%86%E5%BD%A2%E6%80%81"><span class="toc-number">8.11.2.</span> <span class="toc-text">2. 结果集形态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.11.3.</span> <span class="toc-text">3. 语法与使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GROUP-BY"><span class="toc-number">8.11.3.1.</span> <span class="toc-text">(1) GROUP BY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-PARTITION-BY"><span class="toc-number">8.11.3.2.</span> <span class="toc-text">(2) PARTITION BY</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">8.11.4.</span> <span class="toc-text">4. 关键区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">8.11.5.</span> <span class="toc-text">5. 如何选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="toc-number">8.11.6.</span> <span class="toc-text">一句话总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E3%80%81%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.</span> <span class="toc-text">子查询、联合查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2-%E6%9C%80%E5%A5%BD%E5%8A%A0%E5%88%AB%E5%90%8D"><span class="toc-number">9.1.</span> <span class="toc-text">子查询(最好加别名)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.1.1.</span> <span class="toc-text">单行子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.1.2.</span> <span class="toc-text">多行子查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.2.</span> <span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%88JOIN%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">连接查询（JOIN）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E8%BF%9E%E6%8E%A5-%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5-%EF%BC%9A"><span class="toc-number">9.3.1.</span> <span class="toc-text">笛卡尔连接(交叉连接)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%EF%BC%9A%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.3.2.</span> <span class="toc-text">自然连接：一种特殊的内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.3.3.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.3.4.</span> <span class="toc-text">自连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%EF%BC%9A%EF%BC%88%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E4%B8%8D%E6%98%AF%E7%AD%89%E5%8F%B7%EF%BC%89"><span class="toc-number">9.3.5.</span> <span class="toc-text">不等值连接：（过滤条件的符号不是等号）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.3.6.</span> <span class="toc-text">多表连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.3.7.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#on%E5%92%8Cwhere%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.8.</span> <span class="toc-text">on和where使用区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ON-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.3.8.1.</span> <span class="toc-text">1. ON 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-WHERE-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.3.8.2.</span> <span class="toc-text">2. WHERE 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">9.3.8.3.</span> <span class="toc-text">3. 关键区别总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8D%E5%90%8C-JOIN-%E7%B1%BB%E5%9E%8B%E4%B8%8B%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.3.8.4.</span> <span class="toc-text">4. 不同 JOIN 类型下的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%95%E6%97%B6%E7%94%A8-ON-%E6%88%96-WHERE%EF%BC%9F"><span class="toc-number">9.3.8.5.</span> <span class="toc-text">5. 何时用 ON 或 WHERE？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="toc-number">9.3.8.6.</span> <span class="toc-text">6. 一句话总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.4.</span> <span class="toc-text">集合查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E9%9B%86"><span class="toc-number">9.4.0.1.</span> <span class="toc-text">并集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union-all-%E5%B9%B6%E9%9B%86%E5%85%A8%E9%83%A8%E6%98%BE%E7%A4%BA"><span class="toc-number">9.4.0.2.</span> <span class="toc-text">union all 并集全部显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E9%9B%86"><span class="toc-number">9.4.0.3.</span> <span class="toc-text">交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E9%9B%86minus"><span class="toc-number">9.4.0.4.</span> <span class="toc-text">差集minus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">9.4.0.5.</span> <span class="toc-text">灵活应用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exits-%E5%92%8C-exit"><span class="toc-number">10.</span> <span class="toc-text">exits 和 exit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81EXIT%EF%BC%9A%E9%80%80%E5%87%BA%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">10.0.1.</span> <span class="toc-text">一、EXIT：退出流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">10.0.1.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.0.1.3.</span> <span class="toc-text">*语法示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81EXISTS%EF%BC%9A%E5%AD%98%E5%9C%A8%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">10.0.2.</span> <span class="toc-text">二、EXISTS：存在性检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">10.0.2.3.</span> <span class="toc-text">语法示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">10.0.3.</span> <span class="toc-text">三、核心区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">10.0.4.</span> <span class="toc-text">四、常见误区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%AF%E5%B0%86-EXIT-%E7%94%A8%E4%BA%8E-SQL-%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.0.4.1.</span> <span class="toc-text">1. 误将 EXIT 用于 SQL 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%B7%E6%B7%86-EXISTS-%E5%92%8C-IN"><span class="toc-number">10.0.4.2.</span> <span class="toc-text">2. 混淆 EXISTS 和 IN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">10.0.5.</span> <span class="toc-text">五、总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.6.</span> <span class="toc-text">exists和in的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90exists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.6.1.</span> <span class="toc-text">带索引分析exists和in的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">10.0.6.2.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E7%A7%8D%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">2种批量插入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">11.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">11.2.</span> <span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E7%AD%89%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.</span> <span class="toc-text">定义操作控制等语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A7%86%E5%9B%BE%E5%BA%8F%E5%88%97"><span class="toc-number">12.1.</span> <span class="toc-text">索引视图序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">12.1.1.</span> <span class="toc-text">索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8C%89%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F%EF%BC%88%E5%8D%B3%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E5%90%8C%EF%BC%89"><span class="toc-number">12.1.1.1.</span> <span class="toc-text">一、按存储形式（即索引中存储的内容不同）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">12.1.2.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95"><span class="toc-number">12.1.3.</span> <span class="toc-text">修改索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">12.1.4.</span> <span class="toc-text">删除索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">12.1.5.</span> <span class="toc-text">视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.2.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F"><span class="toc-number">12.2.1.</span> <span class="toc-text">事务的开始和结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BF%9D%E5%AD%98%E7%82%B9%E5%8A%9F%E8%83%BD"><span class="toc-number">12.2.2.</span> <span class="toc-text">Oracle 的事务保存点功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%AE%83%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">12.2.3.</span> <span class="toc-text">排它锁和共享锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle%E9%94%81%E8%A1%A8%E8%A7%A3%E9%94%81-system%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="toc-number">12.2.4.</span> <span class="toc-text">Oracle锁表解锁 system用户登录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E4%B9%89%E8%AF%8D"><span class="toc-number">12.3.</span> <span class="toc-text">同义词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="toc-number">12.4.</span> <span class="toc-text">数据字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-number">12.5.</span> <span class="toc-text">数据导入导出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#with-as-%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">13.</span> <span class="toc-text">with..as 子查询</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/25/RAG%E6%A3%80%E7%B4%A2%E7%94%9F%E6%88%90/" title="RAG检索生成"><img src="/img/lita3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RAG检索生成"/></a><div class="content"><a class="title" href="/2025/08/25/RAG%E6%A3%80%E7%B4%A2%E7%94%9F%E6%88%90/" title="RAG检索生成">RAG检索生成</a><time datetime="2025-09-18T01:53:30.365Z" title="更新于 2025-09-18 09:53:30">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/14/Dify%E6%95%99%E7%A8%8B/" title="Dify教程"><img src="/img/lita6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dify教程"/></a><div class="content"><a class="title" href="/2025/09/14/Dify%E6%95%99%E7%A8%8B/" title="Dify教程">Dify教程</a><time datetime="2025-09-14T08:35:36.138Z" title="更新于 2025-09-14 16:35:36">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/25/frp-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" title="frp+服务器:实现内网穿透"><img src="/img/lita4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="frp+服务器:实现内网穿透"/></a><div class="content"><a class="title" href="/2025/07/25/frp-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" title="frp+服务器:实现内网穿透">frp+服务器:实现内网穿透</a><time datetime="2025-09-10T03:02:30.433Z" title="更新于 2025-09-10 11:02:30">2025-09-10</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Yinjin Yao</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div><div class="footer_custom_text">感谢阅读</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入以搜索内容..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>