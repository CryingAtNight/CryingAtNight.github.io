<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Yinjin Yao的个人笔记 | Yinjin Yao的个人笔记</title><meta name="author" content="Yinjin Yao"><meta name="copyright" content="Yinjin Yao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker 介绍Docker软件介绍Docker 开源项目背景​     Docker 是基于 Go 语言实现的开源容器项目 它诞生于 2013 年年初，最初发起者是 dotCloud 公司 Docker 自开源后受到业界广泛的关注和参与，目前已有 80 多个相关开源组 件项目（包括 Containerd Moby Swarm 等），逐渐形成了围 Docker 容器的完整的生态体系.现在主流的操">
<meta property="og:type" content="article">
<meta property="og:title" content="Yinjin Yao的个人笔记">
<meta property="og:url" content="https://cryingatnight.github.io/2025/07/19/typora/docker%20%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="Yinjin Yao的个人笔记">
<meta property="og:description" content="Docker 介绍Docker软件介绍Docker 开源项目背景​     Docker 是基于 Go 语言实现的开源容器项目 它诞生于 2013 年年初，最初发起者是 dotCloud 公司 Docker 自开源后受到业界广泛的关注和参与，目前已有 80 多个相关开源组 件项目（包括 Containerd Moby Swarm 等），逐渐形成了围 Docker 容器的完整的生态体系.现在主流的操">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cryingatnight.github.io/img/lita6.jpg">
<meta property="article:published_time" content="2025-07-19T15:30:40.147Z">
<meta property="article:modified_time" content="2025-07-14T15:15:16.752Z">
<meta property="article:author" content="Yinjin Yao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cryingatnight.github.io/img/lita6.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://cryingatnight.github.io/2025/07/19/typora/docker%20%E4%BB%8B%E7%BB%8D/",
  "image": "https://cryingatnight.github.io/img/lita6.jpg",
  "datePublished": "2025-07-19T15:30:40.147Z",
  "dateModified": "2025-07-14T15:15:16.752Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yinjin Yao",
      "url": "https://cryingatnight.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/headimage.png"><link rel="canonical" href="https://cryingatnight.github.io/2025/07/19/typora/docker%20%E4%BB%8B%E7%BB%8D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Yinjin Yao的个人笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/headimage.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-flask"></i><span> 实验室</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://121.199.61.105/"><i class="fa-fw fas fa-q"></i><span> 豆瓣网开发</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fuckornot.on.websim.com/"><i class="fa-fw fa fa-trophy"></i><span> 上不上AI评分系统</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fontawesome.com/icons"><i class="fa-fw fa fa-check-circle"></i><span> font-awesome v6 图标</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/lita6.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/headimage.png" alt="Logo"><span class="site-name">Yinjin Yao的个人笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">Yinjin Yao的个人笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-flask"></i><span> 实验室</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://121.199.61.105/"><i class="fa-fw fas fa-q"></i><span> 豆瓣网开发</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fuckornot.on.websim.com/"><i class="fa-fw fa fa-trophy"></i><span> 上不上AI评分系统</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://fontawesome.com/icons"><i class="fa-fw fa fa-check-circle"></i><span> font-awesome v6 图标</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-19T15:30:40.147Z" title="发表于 2025-07-19 23:30:40">2025-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-14T15:15:16.752Z" title="更新于 2025-07-14 23:15:16">2025-07-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h1><h2 id="Docker软件介绍"><a href="#Docker软件介绍" class="headerlink" title="Docker软件介绍"></a>Docker软件介绍</h2><h3 id="Docker-开源项目背景"><a href="#Docker-开源项目背景" class="headerlink" title="Docker 开源项目背景"></a>Docker 开源项目背景</h3><p>​     Docker 是基于 Go 语言实现的开源容器项目 它诞生于 2013 年年初，最初发起者是 dotCloud 公司 Docker 自开源后受到业界广泛的关注和参与，目前已有 80 多个相关开源组 件项目（包括 Containerd Moby Swarm 等），逐渐形成了围 Docker 容器的完整的生态体系.现在主流的操作系统包括linux各大发行版本,Mac OS ,windows等都支持Docker.各大云服务提供商也纷纷推出了基于Docker的服务.</p>
<p>Docker的构想是要实现”Build ship and run any App ,Any where” 即通过对应用的封装(packaging),分发(distribution),部署(deploymen).运行(runtime)生命周期进行管理,达到应用组件级别的”一次封装,到处运行”的目的.这些应用组件即可以是一个Web应用,一个编译环境,也可以是一套数据库平台服务,甚至是一个操作系统或集群.可以说Docker首次为应用的开发,运行和部署提供了”一站式”的实用解决方案.</p>
<h3 id="Docker的演化"><a href="#Docker的演化" class="headerlink" title="Docker的演化"></a>Docker的演化</h3><p>Docker的诞生基于linux的容器技术(Linux Containers,LXC),”容器有效的将由单个操作系统管理的资源划分到孤立的组中,以更好地在孤立的组之间平衡有冲突的资源使用需求.与虚拟化相比这样既不需要指令级模拟,也不需要即时编译.容器可以在核心CPU本地运行指令,而不需要任何专门的解释机制.此外,也避免了准虚拟化和系统调用替换中的复杂性.</p>
<p>在LXC基础上,Docker优化了容器的使用体验.首先提供了各种容器的管理工具(用于分发,版本,移植等),让用户无须关注底层操作,更加简单明了的管理和使用容器.其次,Docker通过引入分层文件系统构建和高效的镜像机制,减低了迁移难度,极大的改善 了用户体验.Docker容器可以理解为一种轻量级沙盒.每一个容器内运行一个应用,不同的容器项目隔离,容器之间也可以通过网络相互通信.Docker容器的创建和停止十分快速,几乎跟创建和终止原生应用一致;另外Docker容器自生对系统资源的额外需求也十分有限,远低于虚拟机</p>
<h3 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h3><p>对于开发和运维来说,最梦寐以求的效果就是一次创建或部署之后可以在任意地方,任意时间让应用正常运行,而Docker就是实现这一目标的强大工具.</p>
<h4 id="更快的交付和部署"><a href="#更快的交付和部署" class="headerlink" title="更快的交付和部署"></a>更快的交付和部署</h4><p>开发人员可以使用镜像来快速构建一套标准的开发环境,开发完成以后,测试和运维人员只需要使用开发人员构建的镜像直接进行测试和部署,而不是重新安装系统环境,这样可以确保生产环境和开发环境无缝运行.通过对容器的快速创建和删除,实现软件版本的快速迭代,节约开发,测试,部署的大量时间,并整个过程可见,</p>
<h4 id="更高效的资源利用"><a href="#更高效的资源利用" class="headerlink" title="更高效的资源利用"></a>更高效的资源利用</h4><p>运行Docker容器不需要额外的虚拟化管理程序,(vmware,Hyper)的支持,Docker是内核级的虚拟化,可以实现更高的性能,同时对资源的额外需求很低.Docker的性能比VMware高一两个数量级.</p>
<h4 id="更轻松的迁移和扩展"><a href="#更轻松的迁移和扩展" class="headerlink" title="更轻松的迁移和扩展"></a>更轻松的迁移和扩展</h4><p>Docker容器几乎可以在任意的平台上运行,包括物理机,虚拟机,公有云,私有云,个人电脑,服务器等,同时支持主流的操作系统发行版本.这种兼容让用户可以在不同的平台间迁移应用.</p>
<h3 id="Docker和vmware技术比较"><a href="#Docker和vmware技术比较" class="headerlink" title="Docker和vmware技术比较"></a>Docker和vmware技术比较</h3><table>
<thead>
<tr>
<th>特性</th>
<th>容器技术</th>
<th>虚拟化技术</th>
</tr>
</thead>
<tbody><tr>
<td>启动速度</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>较弱</td>
</tr>
<tr>
<td>内存代价</td>
<td>很小</td>
<td>较多</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>运行密度</td>
<td>单机支持上千容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>隔离性</td>
<td>安全隔离</td>
<td>完全隔离</td>
</tr>
<tr>
<td>迁移性</td>
<td>优秀</td>
<td>一般</td>
</tr>
</tbody></table>
<h3 id="Docker和虚拟化"><a href="#Docker和虚拟化" class="headerlink" title="Docker和虚拟化"></a>Docker和虚拟化</h3><p>虚拟化技术是一个通用的概念,在计算机领域一般指计算的虚拟化或服务器虚拟化.</p>
<blockquote>
<p>在计算机技术中,虚拟化是一种资源管理技术,是将计算机的各种实体资源,如服务器,网络,内存以及存储等予以抽象转换后呈现出来,打破实体实体结构间不可切割的障碍,使用户可以用比原本的组态更好的方式来应用这些资源,.</p>
</blockquote>
<p>可见虚拟化的核心是对资源的抽象,目标往往是为了在同一个主机上运行多个系统或应用,从而提高系统资源的利用率,并且带来成本的减低,管理的方便和容错,容灾的目标.</p>
<p>虚拟化技术可以分为<strong>硬件虚拟化</strong>和<strong>软件虚拟化</strong>,其中真正的硬件虚拟化比较少,网卡中的单根多IO虚拟化属于此范畴.软件虚拟化又分为<strong>应用虚拟化</strong>和<strong>平台虚拟化</strong>,软件虚拟化一般指模拟设备或类似wine这样的软件,平台虚拟化又分为:<strong>完全虚拟化,硬件辅助虚拟化,部分虚拟化超虚拟化,操作系统级虚拟化</strong></p>
<ol>
<li>完全虚拟化: vmware, VirtualBox</li>
<li>硬件虚拟化:利用CPU辅助支持(Intel-VT,AMD-V) VMware,KVM</li>
<li>部分虚拟化:只针对部分硬件资源进行虚拟化(操作系统需要进行修改)</li>
<li>超虚拟化:部分硬件接口以软件的形式提供给客户机操作系统(早期Xen)</li>
<li>操作系统级虚拟化:内核通过创建多个虚拟的操作系统(内核和库)来隔离不同的进程.Docker</li>
</ol>
<p>容器技术就属于操作系统虚拟化范畴,操作系统虚拟化最大的特点就是不需要额外的supervisor支持.</p>
<p><img src="/Docker%20%E4%BB%8B%E7%BB%8D.assets/u=1973835576,4009987039&fm=253&fmt=auto&app=138&f=PNG.webp" alt="点击查看图片来源"></p>
<h3 id="Docker镜像介绍"><a href="#Docker镜像介绍" class="headerlink" title="Docker镜像介绍"></a>Docker镜像介绍</h3><p>Docker镜像类似于虚拟机机镜像,可以将它理解为一个只读的模板.</p>
<p>镜像是创建Docker容器的基础.通过版本管理和增量的文件系统创建和更新现有的镜像,用户可以从网上下载做好的镜像直接使用.</p>
<h3 id="Docker容器介绍"><a href="#Docker容器介绍" class="headerlink" title="Docker容器介绍"></a>Docker容器介绍</h3><p>Docker容器类似于一个轻量级的沙箱,Docker利用容器来运行和隔离应用.</p>
<p>容器时从镜像的应用运行实例.它可以启动,开始,停止,删除而容器都是彼此相互隔离,互不可见的.可以把容器看作一个简易版的linux系统环境以及运行在其中的应用程序打包而成的盒子.</p>
<blockquote>
<p>镜像自身是只读的.容器从镜像启动的时候,会在镜像的最上层创建一个可写层.</p>
</blockquote>
<h3 id="Docker仓库介绍"><a href="#Docker仓库介绍" class="headerlink" title="Docker仓库介绍"></a>Docker仓库介绍</h3><p>Docker仓库类似于代码仓库,是Docker集中存放镜像文件的场所. </p>
<p>Docker仓库分为<strong>公开仓库</strong>和<strong>私有仓库</strong>两种形式. </p>
<blockquote>
<p>Docker仓库镜像的设计理念于git代码仓库的概念非常相似.</p>
</blockquote>
<h3 id="docker三剑客"><a href="#docker三剑客" class="headerlink" title="docker三剑客"></a>docker三剑客</h3><h4 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h4><p>Compose项目是Docker官方的开源项目，定位是“定义和运行多个Docker容器的应用”，其前身是开源项目Fig，目前仍然兼容Fig格式的模板文件。 通过之前的文章，我们知道使用一个Dockerfile模板文件，可以让用户很方便地定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。</p>
<p>Compose中有两个重要的概念：</p>
<p>服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。项目（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义。</p>
<p>Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<h4 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker machine"></a>docker machine</h4><p>Docker Machine是Docker官方三剑客项目之一，负责使用Docker的第一步，在多种平台上快速安装Docker环境。它支持多种平台，让用户可以在很短时间内搭建一套Docker主机集群。</p>
<h4 id="docker-Swarm"><a href="#docker-Swarm" class="headerlink" title="docker Swarm"></a>docker Swarm</h4><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，也能够在主机上创建容器集群服务.作为容器集群管理器 ，Swarm最大的优势之一就是100%支持标准的Docker API。各种基于标准API的工具，如Compose、docker-py，各种管理软件，甚至Docker本身等都可以很容易地与Swarm进行集成。这大大方便了用户将原先基于单节点的系统移植到Swarm上。同时Swarm内置了对Docker网络插件的支持，用户可以很容易地部署跨主机的容器集群服务。</p>
<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>用户可以访问 Docker 官网的 Get Docker ( https: &#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.docker.com/get">www.docker.com/get</a> docker ）页面，查 看获取 Docker 的方式，以及 Docker 支持的平台类型.</p>
<p>目前 Docker 支持 Docker 擎、 Docker Hub Docker Cloud 等多种服务 D Docker 引擎：包括支持在桌面系统或云平台安装 Docker ，以及为企业提供简单安全 弹性的容器集群编排和管理； DockerHub ：官方提供的 托管服务，可以提供公有或私有的镜像仓库； DockerCloud ：官方提供的容器云服务，可以完成容器的部署与管理，可以完整地支 持容器化项目，还有 CI CD 功能 Docker 目前分为两个版本：社区版本（ Community Edition, CE ）和企业版本 (Enterprise Edition, EE 社区版本包括大部分的核心功能，企业版本则通过付费形式提供 认证支持、镜像管理 容器托管 安全扫描等高级服务</p>
<h2 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h2><p>目前市面上主流的CPU 都早已支持硬件虚拟化特性.对于Windows 10 的用户来说， Docker 官方为 64 Windows 10 Pro 环境（需支持 Hyper-V) 提供了原生虚拟化应用 Docker for Windows. Windows环境下的 Docker CE 同样支持两个版 稳定版和测试版  下载地址可见官网文档中心的 Get Docker–&gt;Docker CE–&gt; Windows .</p>
<ol>
<li><p>首先，双击exe 文件进行安装</p>
</li>
<li><p>安装完成后点击 OK 开启 hyper-V </p>
</li>
<li><p>安装wsl_update</p>
</li>
<li><p>在C:\Users\用户名\  下放.wslconfig配置文件</p>
</li>
</ol>
<h2 id="centos安装"><a href="#centos安装" class="headerlink" title="centos安装"></a>centos安装</h2><p> Docker 目前支持 CentOS 及以后的版本 系统的要求跟 Ubuntu 情况类似， 64 位操作 系统，内核版本至少为 3.10 </p>
<p>首先，为了方便添加软件源，以及支持 devicemapper 存储类型，安装如下软件包：</p>
<p>最小化安装整体命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭selinux</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.拷贝一份新的阿里云的 下载源 到 /etc/yum.repos.d/下</span> </span><br><span class="line">mv /root/CentOS-Base.repo /etc/yum.repos.d/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.清空原下载池</span></span><br><span class="line">sudo yum clean all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3. 加载新源</span></span><br><span class="line">sudo yum makecache</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.添加阿里yum源</span></span><br><span class="line"> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确保 yum 包更新到最新。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> yum update</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.安装依赖包</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装工具包</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装基础软件</span></span><br><span class="line">yum install -y net-tools rsync vim wget ntp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装gcc</span></span><br><span class="line">yum -y install gcc gcc-c++ libstdc++-devel</span><br><span class="line"> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"> yum clean all</span><br><span class="line"> yum makecache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">3.安装docker</span></span><br><span class="line"> yum -y install docker-ce</span><br><span class="line"> ./get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">4.启动docker</span></span><br><span class="line"> systemctl enable --now docker</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">5.镜像加速</span></span><br><span class="line"> sudo mkdir -p /etc/docker</span><br><span class="line"> sudo cat /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://dockerhub.icu&quot;,</span><br><span class="line">    &quot;https://docker.registry.cyou&quot;,</span><br><span class="line">    &quot;https://docker-cf.registry.cyou&quot;,</span><br><span class="line">    &quot;https://dockercf.jsdelivr.fyi&quot;,</span><br><span class="line">    &quot;https://docker.jsdelivr.fyi&quot;,</span><br><span class="line">    &quot;https://dockertest.jsdelivr.fyi&quot;,</span><br><span class="line">    &quot;https://mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://dockerproxy.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;,</span><br><span class="line">    &quot;https://docker.m.daocloud.io&quot;,</span><br><span class="line">    &quot;https://docker.nju.edu.cn&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;https://mirror.iscas.ac.cn&quot;,</span><br><span class="line">    &quot;https://docker.rainbond.cc&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"> sudo systemctl daemon-reload</span><br><span class="line"> sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.拷贝一份新的阿里云的 下载源 到 /etc/yum.repos.d/下</span> </span><br><span class="line">mv /etc/yum.repos.d/ /root/CentOS-Base.repo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.清空原下载池</span></span><br><span class="line">sudo yum clean all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3. 加载新源</span></span><br><span class="line">sudo yum makecache</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确保 yum 包更新到最新。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> yum update</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行 Docker 安装脚本。</span></span><br><span class="line">curl -fsSL https://get.docker.com/ -o get-docker.sh</span><br><span class="line"> curl -fsSL https://get.docker.com -o install-docker.sh</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行脚本</span></span><br><span class="line">sh get-docker.sh --mirror ALiyun</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行这个脚本会添加 docker.repo 源并安装 Docker</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动 Docker 进程。</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">验证 docker 是否安装成功并在容器中执行一个测试的镜像。</span></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>





<h1 id="images镜像使用"><a href="#images镜像使用" class="headerlink" title="images镜像使用"></a>images镜像使用</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>docker image build</td>
<td>从Docker文件构建映像</td>
<td>docker image build [OPTIONS] PATH</td>
</tr>
<tr>
<td>docker image history</td>
<td>显示映像的历史记录</td>
<td></td>
</tr>
<tr>
<td><strong>docker image import</strong></td>
<td>从tarball导入内容以创建文件系统映像</td>
<td></td>
</tr>
<tr>
<td>docker image inspect</td>
<td>显示一个或多个映像的详细信息</td>
<td></td>
</tr>
<tr>
<td><strong>docker image load</strong></td>
<td>从tar存档或STDIN加载映像</td>
<td></td>
</tr>
<tr>
<td>docker image ls</td>
<td>列出映像</td>
<td></td>
</tr>
<tr>
<td>docker image prune</td>
<td>删除未使用的映像</td>
<td></td>
</tr>
<tr>
<td><strong>docker image pull</strong></td>
<td>从注册表中拉出映像或存储库</td>
<td></td>
</tr>
<tr>
<td>docker image push</td>
<td>将映像或存储库推送到注册表</td>
<td></td>
</tr>
<tr>
<td>docker image rm</td>
<td>删除一个或多个映像</td>
<td></td>
</tr>
<tr>
<td><strong>docker image save</strong></td>
<td>将一个或多个映像保存到tar存档(默认情况下流式传输到STDOUT)</td>
<td></td>
</tr>
<tr>
<td>docker  search</td>
<td>查询镜像</td>
<td></td>
</tr>
</tbody></table>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><h3 id="docker-image-pull命令"><a href="#docker-image-pull命令" class="headerlink" title="docker image pull命令"></a>docker image pull命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker search </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull tomcat #下载最新的版本</span><br><span class="line">docker pull tomcat:  #下载指定版本</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过添加 registry-mirror 参数指定镜像加载源</span></span><br><span class="line">docker pull --registry-mirror=hub.c.163.com tomcat:9.0.6</span><br><span class="line">docker pull hub.c.163.com/public/ubuntu:18.04</span><br><span class="line">docker pull hub.c.163.com/public/tomcat:9.0.</span><br></pre></td></tr></table></figure>

<p>docker image pull命令用于从 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a> 注册表中拉出映像或存储库。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--all-tags, -a</code></td>
<td>false</td>
<td>在存储库中下载所有标记的映像</td>
</tr>
<tr>
<td><code>--disable-content-trust</code></td>
<td>true</td>
<td>跳过映像验证</td>
</tr>
</tbody></table>
<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看当前本地镜像</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">tomcat       latest    2362f0cdbf14   12 days ago   474MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>–all , -a</td>
<td>显示所有镜像（默认情况下中间镜像不会显示）</td>
</tr>
<tr>
<td>–digests</td>
<td>显示镜像摘要信息</td>
</tr>
<tr>
<td>–filter , -f</td>
<td>根据给定条件筛选镜像</td>
</tr>
<tr>
<td>–format</td>
<td>指定自定义打印格式</td>
</tr>
<tr>
<td>–no-trunc</td>
<td>显示完整的镜像ID</td>
</tr>
<tr>
<td>–quiet , -q</td>
<td>只显示镜像ID</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>REPOSITORY</td>
<td>镜像仓库源名称</td>
<td></td>
</tr>
<tr>
<td>TAG</td>
<td>镜像版本号</td>
<td></td>
</tr>
<tr>
<td>IMAGE ID</td>
<td>镜像ID</td>
<td></td>
</tr>
<tr>
<td>CREATED</td>
<td>创建时间</td>
<td></td>
</tr>
<tr>
<td>SIZE</td>
<td>镜像大小</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search hello #查找镜像</span><br><span class="line">docker search --limit 5 hello #查看前5个镜像</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="docker-image-inspect命令"><a href="#docker-image-inspect命令" class="headerlink" title="docker image inspect命令"></a>docker image inspect命令</h3><p>docker image inspect命令用于显示一个或多个映像的详细信息。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker[image] inspect NAME:TAG</span></span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--format, -f</code></td>
<td></td>
<td>使用给定的Go模板格式化输出</td>
</tr>
</tbody></table>
<p>例如查看镜像 ubuntu:18.04 的详细信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect ubuntu:18.04</span></span><br></pre></td></tr></table></figure>

<h2 id="删除清理镜像"><a href="#删除清理镜像" class="headerlink" title="删除清理镜像"></a>删除清理镜像</h2><h3 id="docker-image-rm命令"><a href="#docker-image-rm命令" class="headerlink" title="docker image rm命令"></a>docker image rm命令</h3><p>镜像删除使用 <strong>docker rmi</strong> 命令，比如我们删除 hello-world 镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker rmi hello-world</span></span><br></pre></td></tr></table></figure>

<p>docker image rm命令用于删除一个或多个映像。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--force, -f</code></td>
<td>false</td>
<td>强制删除映像</td>
</tr>
<tr>
<td><code>--no-prune</code></td>
<td>false</td>
<td>不要删除未标记的父映像</td>
</tr>
</tbody></table>
<h3 id="docker-image-prune命令"><a href="#docker-image-prune命令" class="headerlink" title="docker image prune命令"></a>docker image prune命令</h3><p>docker image prune命令用于删除未使用的映像。 如果指定了<code>-a</code>，还将删除任何容器未引用的所有映像。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image prune [OPTIONS]</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--all, -a</code></td>
<td>false</td>
<td>显示所有映像(默认隐藏中间映像)</td>
</tr>
<tr>
<td><code>--force, -f</code></td>
<td>false</td>
<td>不要提示确认</td>
</tr>
</tbody></table>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h3 id="docker-image-build"><a href="#docker-image-build" class="headerlink" title="docker image build"></a>docker image build</h3><p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--build-arg</code></td>
<td></td>
<td>设置构建时变量</td>
</tr>
<tr>
<td><code>--cache-from</code></td>
<td></td>
<td>要考虑作为缓存源的映像</td>
</tr>
<tr>
<td><code>--cgroup-parent</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>--cgroup-parent</code></td>
<td></td>
<td>容器的可选父cgroup</td>
</tr>
<tr>
<td><code>--compress</code></td>
<td>false</td>
<td>使用gzip压缩构建环境</td>
</tr>
<tr>
<td><code>--cpu-period</code></td>
<td>0</td>
<td>限制CPU CFS(完全公平的调度程序)周期</td>
</tr>
<tr>
<td><code>--cpu-quota</code></td>
<td>0</td>
<td>限制CPU CFS(完全公平的调度程序)配额</td>
</tr>
<tr>
<td><code>--cpu-shares, -c</code></td>
<td>0</td>
<td>CPU比例(相对权重)</td>
</tr>
<tr>
<td><code>--cpuset-cpus</code></td>
<td></td>
<td>允许执行的CPU(0-3,0)</td>
</tr>
<tr>
<td><code>--cpuset-mems</code></td>
<td></td>
<td>允许执行的内存(0-3,0.1)</td>
</tr>
<tr>
<td><code>--disable-content-trust</code></td>
<td>true</td>
<td>跳过映像验证</td>
</tr>
<tr>
<td><code>--file, -f</code></td>
<td></td>
<td>Dockerfile的名称(默认为’<code>PATH/Dockerfile</code>‘)</td>
</tr>
<tr>
<td><code>--force-rm</code></td>
<td>false</td>
<td>总是删除中间容器</td>
</tr>
<tr>
<td><code>--isolation</code></td>
<td></td>
<td>容器隔离技术</td>
</tr>
<tr>
<td><code>--label</code></td>
<td></td>
<td>设置映像的元数据</td>
</tr>
<tr>
<td><code>--memory, -m</code></td>
<td></td>
<td>内存限制</td>
</tr>
<tr>
<td><code>--memory-swap</code></td>
<td></td>
<td>交换限制等于内存加交换：’<code>-1</code>‘表示启用无限制的交换</td>
</tr>
<tr>
<td><code>--network</code></td>
<td>default</td>
<td>在构建期间设置RUN指令的组网模式</td>
</tr>
<tr>
<td><code>--no-cache</code></td>
<td>false</td>
<td>构建映像时不要使用缓存</td>
</tr>
<tr>
<td><code>--pull</code></td>
<td>false</td>
<td>始终尝试拉一个较新版本的映像</td>
</tr>
<tr>
<td><code>--quiet, -q</code></td>
<td>false</td>
<td>抑制构建输出并打印映像ID成功</td>
</tr>
<tr>
<td><code>--rm</code></td>
<td>true</td>
<td>成功构建后移除中间容器</td>
</tr>
<tr>
<td><code>--security-opt</code></td>
<td></td>
<td>安全选项</td>
</tr>
<tr>
<td><code>--shm-size</code></td>
<td></td>
<td><code>/dev/shm</code>的大小，默认值为：64MB</td>
</tr>
<tr>
<td><code>--squash</code></td>
<td>false</td>
<td>将新建的层压成一个新的层</td>
</tr>
<tr>
<td><code>--tag, -t</code></td>
<td></td>
<td>名称和可选的“<code>name:tag</code>”格式的标签</td>
</tr>
<tr>
<td><code>--ulimit</code></td>
<td></td>
<td>Ulimit选项</td>
</tr>
</tbody></table>
<h3 id="docker-image-save命令"><a href="#docker-image-save命令" class="headerlink" title="docker image save命令"></a>docker image save命令</h3><p>docker image save命令用于将一个或多个映像保存到tar存档(默认情况下流式传输到STDOUT)。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--output, -o</code></td>
<td></td>
<td>写入一个文件，而不是STDOUT</td>
</tr>
</tbody></table>
<h3 id="使用Dockerfile创建镜像"><a href="#使用Dockerfile创建镜像" class="headerlink" title="使用Dockerfile创建镜像"></a>使用Dockerfile创建镜像</h3><h2 id="存出以及载入镜像"><a href="#存出以及载入镜像" class="headerlink" title="存出以及载入镜像"></a>存出以及载入镜像</h2><h3 id="docker-image-push命令"><a href="#docker-image-push命令" class="headerlink" title="docker image push命令"></a>docker image push命令</h3><p> docker image push命令用于从将映像或存储库推送到注册表。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image push [OPTIONS] NAME[:TAG]</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--disable-content-trust</code></td>
<td>true</td>
<td>跳过映像验证</td>
</tr>
</tbody></table>
<h3 id="docker-image-load命令"><a href="#docker-image-load命令" class="headerlink" title="docker image load命令"></a>docker image load命令</h3><p>docker image load命令用于从tar存档或STDIN加载映像。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image load [OPTIONS]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--input, -i</code></td>
<td></td>
<td>从tar档案文件(而不是STDIN)读取</td>
</tr>
<tr>
<td><code>--quiet, -q</code></td>
<td>false</td>
<td>抑制加载输出</td>
</tr>
</tbody></table>
<h3 id="docker-image-import命令"><a href="#docker-image-import命令" class="headerlink" title="docker image import命令"></a>docker image import命令</h3><p>docker image import命令用于从tarball导入内容以创建文件系统映像。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--change, -c</code></td>
<td></td>
<td>将Dockerfile指令应用于创建的映像</td>
</tr>
<tr>
<td><code>--message, -m</code></td>
<td></td>
<td>为导入的映像设置提交消息</td>
</tr>
</tbody></table>
<p>​                                                                                                                                                                                                                           </p>
<h1 id="container容器使用"><a href="#container容器使用" class="headerlink" title="container容器使用"></a>container容器使用</h1><table>
<thead>
<tr>
<th>指令</th>
<th>指令用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>docker container attach</td>
<td>附加到正在运行的容器</td>
<td></td>
</tr>
<tr>
<td><strong>docker container commit</strong></td>
<td>从容器的更改创建一个新的映像</td>
<td></td>
</tr>
<tr>
<td><strong>docker container cp</strong></td>
<td>在容器和本地文件系统之间复制文件&#x2F;文件夹</td>
<td></td>
</tr>
<tr>
<td><strong>docker container create</strong></td>
<td>创建一个新的容器</td>
<td></td>
</tr>
<tr>
<td>docker container diff</td>
<td>检查容器文件系统上文件或目录的更改</td>
<td></td>
</tr>
<tr>
<td><strong>docker container exec</strong></td>
<td>在运行容器中运行命令</td>
<td></td>
</tr>
<tr>
<td><strong>docker container export</strong></td>
<td>将容器的文件系统导出为tar存档</td>
<td>docker export red_panda &gt; latest.tar</td>
</tr>
<tr>
<td>docker container inspect</td>
<td>显示一个或多个容器的详细信息</td>
<td></td>
</tr>
<tr>
<td><strong>docker container kill</strong></td>
<td>杀死一个或多个运行容器</td>
<td></td>
</tr>
<tr>
<td>docker container logs</td>
<td>获取容器的日志</td>
<td></td>
</tr>
<tr>
<td><strong>docker container ls</strong></td>
<td>列出容器</td>
<td></td>
</tr>
<tr>
<td>docker container pause</td>
<td>暂停一个或多个容器内的所有进程</td>
<td></td>
</tr>
<tr>
<td><strong>docker container port</strong></td>
<td>列出端口映射或容器的特定映射</td>
<td></td>
</tr>
<tr>
<td>docker container prune</td>
<td>取出所有停止的容器</td>
<td></td>
</tr>
<tr>
<td>docker container rename</td>
<td>重命名容器</td>
<td></td>
</tr>
<tr>
<td>docker container restart</td>
<td>重新启动一个或多个容器</td>
<td></td>
</tr>
<tr>
<td><strong>docker container rm</strong></td>
<td>删除(移除)一个或多个容器</td>
<td></td>
</tr>
<tr>
<td><strong>docker container run</strong></td>
<td>在新容器中运行命令</td>
<td></td>
</tr>
<tr>
<td><strong>docker container start</strong></td>
<td>启动一个或多个停止的容器</td>
<td></td>
</tr>
<tr>
<td><strong>docker container stats</strong></td>
<td>显示容器的实时流资源使用统计信息</td>
<td></td>
</tr>
<tr>
<td><strong>docker container stop</strong></td>
<td>停止一个或多个运行容器</td>
<td></td>
</tr>
<tr>
<td><strong>docker container top</strong></td>
<td>显示容器的正在运行的进程</td>
<td></td>
</tr>
<tr>
<td>docker container unpause</td>
<td>取消暂停一个或多个容器内的所有流程</td>
<td></td>
</tr>
<tr>
<td>docker container update</td>
<td>更新一个或多个容器的配置</td>
<td></td>
</tr>
<tr>
<td>docker container wait</td>
<td>阻止一个或多个容器停止，然后打印退出代码</td>
<td></td>
</tr>
</tbody></table>
<h2 id="创建启动容器"><a href="#创建启动容器" class="headerlink" title="创建启动容器"></a>创建启动容器</h2><h3 id="docker-container-create命令"><a href="#docker-container-create命令" class="headerlink" title="docker container create命令"></a>docker container create命令</h3><p>docker container create命令用于创建一个新的容器。</p>
<p><strong>用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">docker container create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line">docker run -it –net=br10 –ip=192.168.10.10 –add-host=host10:192.168.10.10 –name=ins01 stress bash</span><br><span class="line"></span><br><span class="line">docker run -d --name=mysql-server -p 3306:3306 -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=your_password mysql</span><br><span class="line"></span><br><span class="line">docker create -it –expose=&quot;80&quot; –expose=&quot;8080&quot; –expose=&quot;9001&quot; –name=ins01 centos tail -f /tmp/1.log</span><br><span class="line"></span><br><span class="line"> docker create -it –name=ins01 -v=logs:/data/logs centos bash</span><br><span class="line"> docker create -it –name=ins02 –volumes-from=ins01 centos bash</span><br><span class="line"> </span><br><span class="line"> docker run --name mysql -d -p 3306:3306 --net mysql-test -v /usr/mysql/conf:/etc/my.cnf.d -v /usr/mysql/logs:/logs -v /usr/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--restart always \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network-alias mysql \</span><br><span class="line">mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name=fr_tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">-v /root/fr:/usr/local/tomcat/webapps/fr \</span><br><span class="line">tomcat:9.0.44-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name=fr_tomcat \</span><br><span class="line">-p 8888:8080 \</span><br><span class="line">-v /opt/containerData/tomcat/fr:/usr/local/tomcat/webapps/fr \</span><br><span class="line">tomcat:9.0.44-jdk8</span><br><span class="line"></span><br><span class="line"> cp tools.jar /usr/local/tomcat/webapps/fr/WEB-INF/lib/</span><br><span class="line"> cp tools.jar /usr/local/tomcat/lib/</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th>名称，简写</th>
<th>默认</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>--add-host</code></td>
<td>-</td>
<td align="left"><strong>添加自定义的主机到IP映射(<code>host:ip</code>)</strong></td>
</tr>
<tr>
<td><code>--attach, -a</code></td>
<td>-</td>
<td align="left">附加到<code>STDIN</code>，<code>STDOUT</code>或<code>STDERR</code></td>
</tr>
<tr>
<td><code>--blkio-weight</code></td>
<td>0</td>
<td align="left">阻止IO(相对权重)，介于<code>10</code>和<code>1000</code>之间，或<code>0</code>禁用(默认为<code>0</code>)</td>
</tr>
<tr>
<td><code>--blkio-weight-device</code></td>
<td></td>
<td align="left">块IO的权重(相对设备权重)</td>
</tr>
<tr>
<td><code>--cap-add</code></td>
<td></td>
<td align="left">添加Linux功能</td>
</tr>
<tr>
<td><code>--cap-drop</code></td>
<td></td>
<td align="left">删除Linux功能</td>
</tr>
<tr>
<td><code>--cgroup-parent</code></td>
<td></td>
<td align="left">容器的可选父cgroup</td>
</tr>
<tr>
<td><code>--cidfile</code></td>
<td></td>
<td align="left">将容器ID写入文件</td>
</tr>
<tr>
<td><code>--cpu-count</code></td>
<td>0</td>
<td align="left"><strong>CPU数量(仅限Windows)</strong></td>
</tr>
<tr>
<td><code>--cpu-percent</code></td>
<td>0</td>
<td align="left"><strong>CPU百分比(仅限Windows)</strong></td>
</tr>
<tr>
<td><code>--cpu-period</code></td>
<td>0</td>
<td align="left">限制CPU CFS(完全公平的调度程序)周期</td>
</tr>
<tr>
<td><code>--cpu-quota</code></td>
<td>0</td>
<td align="left">限制CPU CFS(完全公平的调度程序)配额</td>
</tr>
<tr>
<td><code>--cpu-rt-period</code></td>
<td>0</td>
<td align="left">限制CPU实时周期(以微秒为单位)</td>
</tr>
<tr>
<td><code>--cpu-rt-runtime</code></td>
<td>0</td>
<td align="left">以微秒限制CPU实时运行时间</td>
</tr>
<tr>
<td><code>--cpu-shares, -c</code></td>
<td>0</td>
<td align="left"><strong>CPU份额(相对重量)</strong></td>
</tr>
<tr>
<td><code>--cpus</code></td>
<td>0.000</td>
<td align="left"><strong>CPU数量</strong></td>
</tr>
<tr>
<td><code>--cpuset-cpus</code></td>
<td></td>
<td align="left">允许执行的CPU(0-3,0)</td>
</tr>
<tr>
<td><code>--cpuset-mems</code></td>
<td></td>
<td align="left">允许执行的内存(0-3,0.1)</td>
</tr>
<tr>
<td><code>--credentialspec</code></td>
<td></td>
<td align="left">托管服务帐户的凭证规格(仅适用于Windows)</td>
</tr>
<tr>
<td><code>--device</code></td>
<td></td>
<td align="left">将主机设备添加到容器</td>
</tr>
<tr>
<td><code>--device-read-bps</code></td>
<td></td>
<td align="left">从设备限制读取速率(每秒字节数)</td>
</tr>
<tr>
<td><code>--device-read-iops</code></td>
<td></td>
<td align="left">从设备限制读取速率(每秒IO)</td>
</tr>
<tr>
<td><code>--device-write-bps</code></td>
<td></td>
<td align="left">限制设备的写入速率(每秒字节数)</td>
</tr>
<tr>
<td><code>--device-write-iops</code></td>
<td></td>
<td align="left">限制写入到设备的速率(IO每秒)</td>
</tr>
<tr>
<td><code>--disable-content-trust</code></td>
<td>true</td>
<td align="left">跳过映像验证</td>
</tr>
<tr>
<td><code>--dns</code></td>
<td></td>
<td align="left">设置自定义DNS服务器</td>
</tr>
<tr>
<td><code>--dns-opt</code></td>
<td></td>
<td align="left">设置DNS选项</td>
</tr>
<tr>
<td><code>--dns-option</code></td>
<td></td>
<td align="left">设置DNS选项</td>
</tr>
<tr>
<td><code>--dns-search</code></td>
<td></td>
<td align="left">设置自定义DNS搜索域</td>
</tr>
<tr>
<td><code>--entrypoint</code></td>
<td></td>
<td align="left">覆盖映像的默认ENTRYPOINT</td>
</tr>
<tr>
<td><strong><code>--env, -e</code></strong></td>
<td></td>
<td align="left"><strong>设置环境变量</strong></td>
</tr>
<tr>
<td><code>--env-file</code></td>
<td></td>
<td align="left">读入环境变量文件</td>
</tr>
<tr>
<td><code>--expose</code></td>
<td></td>
<td align="left">暴露端口或端口范围</td>
</tr>
<tr>
<td><code>--group-add</code></td>
<td></td>
<td align="left">添加其他组加入b</td>
</tr>
<tr>
<td><code>--health-cmd</code></td>
<td></td>
<td align="left">运行命令检查健康状况</td>
</tr>
<tr>
<td><code>--health-interval</code></td>
<td>0s</td>
<td align="left">运行检查之间的时间(<em>ns  | us | ms| s   | m    | h</em>)(默认值<code>0s</code>)</td>
</tr>
<tr>
<td><code>--health-retries</code></td>
<td>0</td>
<td align="left">连续失败需要报告不健康</td>
</tr>
<tr>
<td><code>--health-timeout</code></td>
<td>0s</td>
<td align="left">允许一次检查运行的最长时间(<em>ns   | us| ms | s  | m  | h</em>)(默认值<code>0s</code>)</td>
</tr>
<tr>
<td><code>--help</code></td>
<td>false</td>
<td align="left">打印使用情况</td>
</tr>
<tr>
<td><code>--hostname, -h</code></td>
<td></td>
<td align="left"><strong>容器主机名</strong></td>
</tr>
<tr>
<td><code>--init</code></td>
<td>false</td>
<td align="left">在容器内初始化运行一个转发信号并收集进程</td>
</tr>
<tr>
<td><code>--init-path</code></td>
<td></td>
<td align="left"><code>docker-init</code>二进制文件的路径</td>
</tr>
<tr>
<td><code>--interactive, -i</code></td>
<td>false</td>
<td align="left">保持STDIN打开即使不附加</td>
</tr>
<tr>
<td><code>--io-maxbandwidth</code></td>
<td></td>
<td align="left">系统驱动器的最大IO带宽限制(仅限Windows)</td>
</tr>
<tr>
<td><code>--io-maxiops</code></td>
<td>0</td>
<td align="left">系统驱动器的最大IOPS限制(仅限Windows)</td>
</tr>
<tr>
<td><strong><code>--ip</code></strong></td>
<td></td>
<td align="left"><strong>容器IPv4地址(例如：<code>172.30.100.104</code>)</strong></td>
</tr>
<tr>
<td><code>--ip6</code></td>
<td></td>
<td align="left">容器IPv6地址(例如：<code>2001:db8::33</code>)</td>
</tr>
<tr>
<td><code>--ipc</code></td>
<td></td>
<td align="left">IPC命名空间使用b</td>
</tr>
<tr>
<td><code>--isolation</code></td>
<td></td>
<td align="left">容器隔离技术</td>
</tr>
<tr>
<td><code>--kernel-memory</code></td>
<td></td>
<td align="left"><strong>内核内存限制</strong></td>
</tr>
<tr>
<td><code>--label, -l</code></td>
<td></td>
<td align="left">在容器上设置元数据</td>
</tr>
<tr>
<td><code>--label-file</code></td>
<td></td>
<td align="left">读取标签的行分隔文件</td>
</tr>
<tr>
<td><strong><code>--link</code></strong></td>
<td></td>
<td align="left">添加链接到另一个容器</td>
</tr>
<tr>
<td><strong><code>--link-local-ip</code></strong></td>
<td></td>
<td align="left">添加链接到另一个容器</td>
</tr>
<tr>
<td><code>--log-driver</code></td>
<td></td>
<td align="left">记录容器的驱动程序</td>
</tr>
<tr>
<td><code>--log-opt</code></td>
<td></td>
<td align="left">日志驱动程序选项</td>
</tr>
<tr>
<td><code>--mac-address</code></td>
<td></td>
<td align="left">容器MAC地址(例如：<code>92:d0:c6:0a:29:33</code>)</td>
</tr>
<tr>
<td><code>--memory, -m</code></td>
<td></td>
<td align="left"><strong>内存限制</strong></td>
</tr>
<tr>
<td><code>--memory-reservation</code></td>
<td></td>
<td align="left">内存软限制</td>
</tr>
<tr>
<td><code>--memory-swap</code></td>
<td></td>
<td align="left">交换限制等于内存加交换：’<code>-1</code>‘以启用无限制的交换</td>
</tr>
<tr>
<td><code>--memory-swappiness</code></td>
<td><code>-1</code></td>
<td align="left">调整容器内存swappiness(0到100)</td>
</tr>
<tr>
<td><strong><code>--name</code></strong></td>
<td></td>
<td align="left">为容器指定名称</td>
</tr>
<tr>
<td><strong><code>--net</code></strong></td>
<td><code>default</code></td>
<td align="left">将容器连接到网络</td>
</tr>
<tr>
<td><strong><code>--net-alias</code></strong></td>
<td></td>
<td align="left">为容器添加网络范围的别名</td>
</tr>
<tr>
<td><strong><code>--network</code></strong></td>
<td><code>default</code></td>
<td align="left"><strong>将容器连接到网络</strong></td>
</tr>
<tr>
<td><strong><code>--network-alias</code></strong></td>
<td></td>
<td align="left">为容器添加网络范围的别名</td>
</tr>
<tr>
<td><code>--no-healthcheck</code></td>
<td><code>false</code></td>
<td align="left">禁用任何容器指定的<code>HEALTHCHECK</code></td>
</tr>
<tr>
<td><code>--oom-kill-disable</code></td>
<td></td>
<td align="left">禁用OOM</td>
</tr>
<tr>
<td><code>--oom-score-adj</code></td>
<td>0</td>
<td align="left">调整主机的OOM偏好设置(<code>-1000</code>至<code>1000</code>)</td>
</tr>
<tr>
<td><code>--pid</code></td>
<td></td>
<td align="left">要使用的PID命名空间</td>
</tr>
<tr>
<td><code>--pids-limit</code></td>
<td>0</td>
<td align="left">调整容器<code>pids</code>限制(设置为<code>-1</code>为无限制)</td>
</tr>
<tr>
<td><code>--privileged</code></td>
<td>false</td>
<td align="left">为此容器提供扩展权限</td>
</tr>
<tr>
<td><strong><code>--publish, -p</code></strong></td>
<td></td>
<td align="left">将容器的端口发布到主机</td>
</tr>
<tr>
<td><strong><code>--publish-all, -P</code></strong></td>
<td><code>false</code></td>
<td align="left">将所有暴露的端口发布到随机端口</td>
</tr>
<tr>
<td><strong><code>--read-only</code></strong></td>
<td><code>false</code></td>
<td align="left">将容器的根文件系统挂载为只读</td>
</tr>
<tr>
<td><strong><code>--restart</code></strong></td>
<td>no</td>
<td align="left">重新启动在容器退出时应用的策略</td>
</tr>
<tr>
<td><code>--rm</code></td>
<td>false</td>
<td align="left">退出时自动取出容器</td>
</tr>
<tr>
<td><code>--runtime</code></td>
<td></td>
<td align="left">运行时用于此容器</td>
</tr>
<tr>
<td><code>--security-opt</code></td>
<td></td>
<td align="left">安全选项</td>
</tr>
<tr>
<td><code>--shm-size</code></td>
<td></td>
<td align="left"><code>/dev/shm</code>的大小，默认值为64MB</td>
</tr>
<tr>
<td><code>--stop-signal</code></td>
<td><code>SIGTERM</code></td>
<td align="left">信号停止容器，默认情况下为<em>SIGTERM</em></td>
</tr>
<tr>
<td><code>--stop-timeout</code></td>
<td>0</td>
<td align="left">超时(秒)停止容器</td>
</tr>
<tr>
<td><code>--storage-opt</code></td>
<td></td>
<td align="left">容器的存储驱动程序选项</td>
</tr>
<tr>
<td><code>--sysctl</code></td>
<td>map[]</td>
<td align="left">Sysctl 选项</td>
</tr>
<tr>
<td><code>--tmpfs</code></td>
<td></td>
<td align="left">装载一个 tmpfs 目录</td>
</tr>
<tr>
<td><code>--tty, -t</code></td>
<td>false</td>
<td align="left">分配一个 pseudo-TTY</td>
</tr>
<tr>
<td><code>--ulimit</code></td>
<td></td>
<td align="left">Ulimit选项</td>
</tr>
<tr>
<td><code>--user, -u</code></td>
<td></td>
<td align="left">Username 或 UID (格式: &lt;name  | uid&gt;[:&lt;group | gid&gt;])</td>
</tr>
<tr>
<td><code>--userns</code></td>
<td></td>
<td align="left">要使用的用户名空间</td>
</tr>
<tr>
<td><code>--uts</code></td>
<td></td>
<td align="left">使用UTS命名空间</td>
</tr>
<tr>
<td><strong><code>--volume, -v</code></strong></td>
<td></td>
<td align="left"><strong>绑定卷</strong></td>
</tr>
<tr>
<td><code>--volume-driver</code></td>
<td></td>
<td align="left">容器的可选卷驱动程序</td>
</tr>
<tr>
<td><strong><code>--volumes-from</code></strong></td>
<td></td>
<td align="left"><strong>指定容器以装载卷</strong></td>
</tr>
<tr>
<td><code>--workdir, -w</code></td>
<td></td>
<td align="left">容器内的工作目录</td>
</tr>
</tbody></table>
<p>docker container run -itd -p 5000:80 –restart&#x3D;always –name name nginx</p>
<ul>
<li>-d：是否在后台运行容器，默认为否</li>
<li>-i：保持标准输入打开，默认为false</li>
<li>-P：是容器内部端口随机映射到主机的某端口</li>
<li>-p：指定映射到本地端口，例如，-p 11234-11240:1234-1240</li>
<li>-t：是否分配一个伪终端，默认为false</li>
<li>-v：挂载主机上的文件卷到容器内</li>
<li>–name：为容器指定名称</li>
</ul>
<h3 id="docker-start启动容器"><a href="#docker-start启动容器" class="headerlink" title="docker start启动容器"></a>docker start启动容器</h3><p>使用 <code>docker start container-id/container-name</code> 命令启动一个刚刚创建的容器 ，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker start d25d8252253a</span></span><br></pre></td></tr></table></figure>

<h3 id="docker-run新建并启动容器"><a href="#docker-run新建并启动容器" class="headerlink" title="docker run新建并启动容器"></a>docker run新建并启动容器</h3><p>命令 <code>docker run</code> 命令等同于先执行 <code>docker create</code> 再执行 <code>docker start</code>。例如，使用下面的命令输出 Hello World!，之后容器会自动停止。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run ubuntu /bin/echo <span class="string">&#x27;Hello World!&#x27;</span></span></span><br><span class="line">Hello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>docker run</code> 命令，是按照以下的执行流程</p>
<ol>
<li>如果镜像不存在，会先从共有仓库下载镜像</li>
<li>分配一个文件系统给容器，并在只读镜像层外挂载一层可读写层</li>
<li>从宿主主机的配置的网桥接口中桥接一个虚拟接口到容器中</li>
<li>从网桥的地址池中分配一个ip给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕容器自动停止</li>
</ol>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><h4 id="docker-–rm暂停容器"><a href="#docker-–rm暂停容器" class="headerlink" title="docker –rm暂停容器"></a>docker –rm暂停容器</h4><p>例如，启动一个容器，将其暂停</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name <span class="built_in">test</span> --<span class="built_in">rm</span> -it ubuntu bash</span> </span><br><span class="line">root@6d65107c8001:/#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用该命令恢复暂停的容器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker unpause <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<h4 id="docker-stop终止容器"><a href="#docker-stop终止容器" class="headerlink" title="docker stop终止容器"></a>docker stop终止容器</h4><p>可以使用 <code>docker stop[-t|--time[=10]</code> 来终止一个运行的容器，该命令会首先向容器发送 SIGTERM 信号，等待一段时间后（默认为10秒），再发送 SIGKILL 信号来终止容器，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker stop <span class="built_in">test</span></span></span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>此外，可以使用 <code>docker kill</code> 直接发送 SIGKILL 信号来强行终止容器，<code>docker restart</code> 会先终止容器，再启动容器</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在启动容器时，使用 -d 选项，会使容器在后台运行，用户无法看到容器内的输入也无法进行操作，这是有两个命令可以进入容器，分别是 attach 和 exec 名命令</p>
<h3 id="docker-attach进入容器"><a href="#docker-attach进入容器" class="headerlink" title="docker attach进入容器"></a>docker attach进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker attach [option] container</span></span><br></pre></td></tr></table></figure>

<p>这个命名主要支持三个选项，非别是：</p>
<ul>
<li>–detach-keys&#x3D;[]：指定退出 attach 模式的快捷键序列，默认是 ctrl + q 和 ctrl + p</li>
<li>–no-stdin&#x3D;true|false：是否关闭标准输入，默认是false</li>
<li>–sig-proxy&#x3D;true|false：是否代理收到的系统信号给应用进程，默认为true</li>
</ul>
<p>attach 有一个特点，当多个窗口使用 attach 进入同一个容器时，所有的窗口都会同步显示，当一个创建因为命令阻塞了，所有的窗口都会无法操作</p>
<p>进入容器</p>
<h3 id="docker-exec-进入容器"><a href="#docker-exec-进入容器" class="headerlink" title="docker exec 进入容器"></a>docker exec 进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> [option] container</span></span><br></pre></td></tr></table></figure>

<p>比较重要的选项有</p>
<ul>
<li>-d：在容器后台执行命令</li>
<li>–detack-keys&#x3D;””：指定容器切回后台的按键</li>
<li>-e，–env&#x3D;[]：指定环境变了列表</li>
<li>-i：打开标准输入接收用户输入的命令，默认为 false</li>
<li>–privileged&#x3D;true|false：是否给执行命令以最高权限，默认false</li>
<li>-t：分配伪终端</li>
<li>-t，–user：执行命令的用户名</li>
</ul>
<p>例如，进入刚刚创建的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name <span class="built_in">test</span> -itd ubuntu:18.04</span></span><br><span class="line">1647d13558f7d8b7a03f7abbc27414e6f7befa5a6c64a3257210f6755fdcadc6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it <span class="built_in">test</span> bash</span></span><br><span class="line">root@1647d13558f7:/#</span><br></pre></td></tr></table></figure>

<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><h3 id="docker-rm删除容器"><a href="#docker-rm删除容器" class="headerlink" title="docker rm删除容器"></a>docker rm删除容器</h3><p>使用 <code>docker [container] rm [option]</code> 命令来删除容器</p>
<p>支持的选项有</p>
<ul>
<li>-f：强制删除运行中的容器，会先发送 SIGKILL 信号给容器，再进行删除</li>
<li>-l：删除容器的连接，但保留容器</li>
<li>-v：删除容器挂载的数据卷</li>
</ul>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker create --name ubuntu-1 -it ubuntu:18.04</span></span><br><span class="line">daf29b04546cbc2ce21b397c8ebbdec92458a6b40361fe1e3c6cc457a76cb5f8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> ubuntu-1</span></span><br><span class="line">ubuntu-1</span><br></pre></td></tr></table></figure>

<h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><h4 id="docker-export导出容器"><a href="#docker-export导出容器" class="headerlink" title="docker export导出容器"></a>docker export导出容器</h4><p>导出容器，是把一个已经创建的容器导出到一个文件中，命令为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">export</span> -o outputfile container</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">create --name ubuntu-1 -it ubuntu:18.04</span></span><br><span class="line">6294e0db7bf07f0a7e08f098bb44109e5635ec7e959b8340eb822f6236b2a66f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> -o ubuntu-1.tar ubuntu-1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lh</span></span><br><span class="line">-rw-------   1 linchangkun  staff    56M 10 21 00:36 ubuntu-1.tar</span><br></pre></td></tr></table></figure>

<h4 id="docker-import导入容器"><a href="#docker-import导入容器" class="headerlink" title="docker import导入容器"></a>docker import导入容器</h4><p>将导出的容器，可以复制到其他的机器上，导入后会变为镜像，命令为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker import file REPOSITORY[:TAG]</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker import ubuntu-1.tar <span class="built_in">test</span>/u:0.1</span></span><br><span class="line">sha256:9036cbb933c7dfa3e8e96ec1c5d54b55a9374930089a15198471903e506a6208</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY              TAG           IMAGE ID       CREATED         SIZE</span><br><span class="line">test/u                  0.1           9036cbb933c7   3 minutes ago   56.6MB</span><br></pre></td></tr></table></figure>

<p>导出容器再导入成为镜像，会丢失元信息和历史</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="export和save-commit的区别"><a href="#export和save-commit的区别" class="headerlink" title="export和save,commit的区别"></a>export和save,commit的区别</h3><p>export、import命令是一对，save、load命令是一对。</p>
<p>export：导出容器快照为镜像。</p>
<p>import：导入容器快照到<strong>本地镜像库</strong>。docker export和import比较坑，import生成的镜像不能直接run，需要知道之前容器的启动命令。</p>
<p>save：将指定镜像保存成tar文件。</p>
<p>load：导入使用docker save命令导出的镜像。</p>
<p>commit：将已存在容器中的镜像和修改内容提交为一个新的镜像，通过这个方式同样能保存读写层内容。</p>
<p><strong>export应用场景：</strong></p>
<p>  主要用来制作基础镜像，比如从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p>
<p><strong>save应用场景：</strong></p>
<p> 用于镜像迁移到别处。</p>
<p><strong>commit应用场景：</strong></p>
<p> 用于镜像迁移到别处。</p>
<p>通过commit+save+load可以实现：我先在A机器上配置好了一个镜像，然后通过commit生成了镜像，使用save命令生成该镜像对应的tar包，然后移动到B机器上，然后在B机器上执行load命令，加载tar包到本地镜像仓库。	</p>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><h3 id="docker-container-ls命令"><a href="#docker-container-ls命令" class="headerlink" title="docker container ls命令"></a>docker container ls命令</h3><p>查看容器</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>列出当前正在运行的容器, 结果的第一列是container_Id, 第2列是容器名称.</p>
<p>参数：</p>
<ul>
<li>-a :显示所有的容器，包括未运行的。</li>
<li>-f :根据条件过滤显示的内容。</li>
<li>–format :指定返回值的模板文件。</li>
<li>-l :显示最近创建的容器。</li>
<li>-n :列出最近创建的n个容器。</li>
<li>–no-trunc :不截断输出。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>-s :显示总的文件大小。</li>
</ul>
<h3 id="docker-logs查看容器输出"><a href="#docker-logs查看容器输出" class="headerlink" title="docker logs查看容器输出"></a>docker logs查看容器输出</h3><p>使用 <code>docker logs</code> 命令获取容器输出，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs e5f5b35152ed</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs 6b4389195232</span></span><br></pre></td></tr></table></figure>

<p>支持以下选项</p>
<ul>
<li>–details：打印详细信息</li>
<li>-f：保持持续输出</li>
<li>–since string：输出某个时间开始的日志，例如 –since 2021-01-01</li>
<li>–tail string：输出最近的若干日志，例如 –tail 2</li>
<li>-t：显示时间戳信息</li>
<li>–until string：输出某个时间之前的日志</li>
</ul>
<h3 id="docker-inspect查看容器详情"><a href="#docker-inspect查看容器详情" class="headerlink" title="docker inspect查看容器详情"></a>docker inspect查看容器详情</h3><p>使用 <code>docker inspect container</code> 查看容器详情，会以 json 格式返回容器id、创建时间、路径、状态等信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect ubuntu-1</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;6294e0db7bf07f0a7e08f098bb44109e5635ec7e959b8340eb822f6236b2a66f&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-10-20T16:35:38.685585044Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;bash&quot;,</span><br><span class="line">        &quot;Args&quot;: [],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;exited&quot;,</span><br><span class="line">            &quot;Running&quot;: false,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            ......</span><br></pre></td></tr></table></figure>

<h3 id="docker-top查看容器内进程"><a href="#docker-top查看容器内进程" class="headerlink" title="docker top查看容器内进程"></a>docker top查看容器内进程</h3><p>使用 <code>docker top container</code> 查看容器内进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker top ubuntu-1</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                3612                3587                0                   07:46               ?                   00:00:00            bash</span><br><span class="line">root                3650                3612                0                   07:46               ?                   00:00:00            top</span><br></pre></td></tr></table></figure>

<h3 id="docker-stats查看统计信息"><a href="#docker-stats查看统计信息" class="headerlink" title="docker stats查看统计信息"></a>docker stats查看统计信息</h3><p>使用 <code>docker stats container</code> 可以查看统计信息，会显示cpu、内存、存储、网络等使用情况的统计信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker stats ubuntu-1</span></span><br><span class="line">CONTAINER ID   NAME       CPU %     MEM USAGE / LIMIT    MEM %     NET I/O       BLOCK I/O   PIDS</span><br><span class="line">6294e0db7bf0   ubuntu-1   0.00%     1.27MiB / 1.942GiB   0.06%     1.16kB / 0B   0B / 0B     2</span><br></pre></td></tr></table></figure>

<h2 id="其他容器命令"><a href="#其他容器命令" class="headerlink" title="其他容器命令"></a>其他容器命令</h2><h3 id="docker-cp复制文件"><a href="#docker-cp复制文件" class="headerlink" title="docker cp复制文件"></a>docker cp复制文件</h3><p>使用 <code>docker cp</code> 可以在容器和物理机之间复制文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 354488</span><br><span class="line">-rw-r--r--  1 linchangkun  staff     0B 10 24 15:54 2.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制本地文件到容器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">cp</span> ./2.txt ubuntu-1:/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制容器内文件到本地</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">cp</span> ubuntu-1:/3.txt .</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>支持的选项有</p>
<ul>
<li>-L：跟随软连接。默认当原路径是软连接时，默认只复制链接信息，该选项会复制包含链接内容</li>
</ul>
<h3 id="docker-diff查看容器变更"><a href="#docker-diff查看容器变更" class="headerlink" title="docker diff查看容器变更"></a>docker diff查看容器变更</h3><p>使用 <code>docker diff container</code> 查看容器内文件变更</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker diff ubuntu-1</span></span><br><span class="line">A /3.txt</span><br><span class="line">A /hello</span><br><span class="line">A /2.txt</span><br><span class="line">A /2</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br></pre></td></tr></table></figure>

<h3 id="docker-port查看端口映射"><a href="#docker-port查看端口映射" class="headerlink" title="docker port查看端口映射"></a>docker port查看端口映射</h3><p>使用 <code>docker port container</code> 命名可以查看容器端口映射</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name ubuntu-2 -it -p 80:80 ubuntu:18.04</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port ubuntu-2</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:80</span><br></pre></td></tr></table></figure>

<h3 id="docker-update更新容器配置"><a href="#docker-update更新容器配置" class="headerlink" title="docker update更新容器配置"></a>docker update更新容器配置</h3><p>使用 <code>docker update container</code> 命令可以更新容器资源限制配置，比如，cpu核心数、允许使用内存大小、io速度等等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="Docker仓库使用"><a href="#Docker仓库使用" class="headerlink" title="Docker仓库使用"></a>Docker仓库使用</h1><h1 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a>Docker数据管理</h1><p>容器中的管理数据主要有两种方式<br>1.数据卷 Data Volumes 容器内数据直接映射到本地主机环境；</p>
<p>2.数据卷容器（Data Volume Containers 使用特定容器维护数据卷</p>
<p>数据卷可以将主机上的目录&#x2F;文件映射到容器内，并具有以下一些特性：</p>
<ul>
<li>数据卷可以在容器之间共享，方便容器之间共享数据</li>
<li>主机&#x2F;容器内的操作文件，可以立即在容器&#x2F;主机上看到相应的变化</li>
<li>数据卷与容器相互独立，解耦</li>
</ul>
<h2 id="创建数据卷-Data-Volumes"><a href="#创建数据卷-Data-Volumes" class="headerlink" title="创建数据卷(Data Volumes)"></a>创建数据卷(Data Volumes)</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录（文件夹）， 它将主机操作系统目录直接映射进容器</p>
<p>它可以提供很多有用的特性：</p>
<blockquote>
<p>1.数据卷 可以在容器之间共享和重用</p>
<p>2.对数据卷的修改会立马生效</p>
<p>3.对数据卷的更新，不会影响镜像</p>
<p>4.数据卷 默认会一直存在，即使容器被删除</p>
</blockquote>
<p>数据卷相关操作<br>1.宿主机上先创建数据卷，再启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注1： my-vol是数据卷的名称</p>
<p>注2： 创建好的据卷默认会放到&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes路径下，会发现所新建的数据卷位置，查看命令如下：</p>
</blockquote>
<h3 id="查看所有的数据卷"><a href="#查看所有的数据卷" class="headerlink" title="查看所有的数据卷"></a>查看所有的数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>

<h3 id="查看指定数据卷的详细信息"><a href="#查看指定数据卷的详细信息" class="headerlink" title="查看指定数据卷的详细信息"></a>查看指定数据卷的详细信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my-vol </span><br></pre></td></tr></table></figure>

<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm my-vol</span><br></pre></td></tr></table></figure>

<p>用 docker vloume ls 查询一下，如果没有数据卷了，就说明删除成功了</p>
<p><strong>注1</strong>：rm是remove的缩写</p>
<p><strong>注2</strong>：数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷，无主的数据卷可能会占据很多空间， 所以要及时删除</p>
<h3 id="创建一个挂载数据卷的容器"><a href="#创建一个挂载数据卷的容器" class="headerlink" title="创建一个挂载数据卷的容器"></a>创建一个挂载数据卷的容器</h3><p>挂载的意思是临时会挂载身上，可拆卸的 </p>
<p>比如一个人（容器）背了一个包（数据卷） </p>
<p>如果容器要使用数据卷，必须在创建容器的时候挂载数据卷 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd\</span><br><span class="line">    --name tomcat01 \</span><br><span class="line">    --mount source=my-vol,target=/webapp \</span><br><span class="line">    centos:latest</span><br></pre></td></tr></table></figure>

<p>run的意思是创建并且运行并且进入的到容器里面去，但是加了 -d就会在后台运行</p>
<p> -itd的意思是以守护进程方式运行</p>
<p>– name 是给容器取个名字叫 tomcat01</p>
<p>–mount source&#x3D;my-vol 挂载命令 ，表示容器可以使用数据卷</p>
<p>target&#x3D;&#x2F;webapp是挂载容器的这个路径</p>
<p>centos:latest是即镜像名字:版本(或镜像ID)，将使用指定镜像创建容器。另外，Docker会检查本地是否存在指定的镜像</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。 数据卷容器也是一个容器，但是它的目的是专门提供数据卷给其他容器挂载</p>
<h3 id="新建数据卷容器"><a href="#新建数据卷容器" class="headerlink" title="新建数据卷容器"></a><strong>新建数据卷容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name db_data -v /db_data centos</span><br></pre></td></tr></table></figure>

<p><strong>注：通过 -v的指令来指定这个文件夹（db_data）叫数据卷</strong></p>
<p>通过 <strong>dockers ps</strong> 查询 数据卷容器 已经创建成功了</p>
<p>用容器db1测试数据卷容器是否可用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name db1 --volumes-from db_data centos </span><br><span class="line">docker exec -it db1 bash cd db_data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匿名挂载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-v 容器路径</span></span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看本地卷(为名字还是<span class="built_in">id</span>)</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">具名挂载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过 -v 卷名：容器内路径</span></span><br><span class="line">docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span> </span><br><span class="line">docker volume inspect 具名/匿名id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：通过–volumes-from将db_data里面的数据卷挂载到当前容器</p>
<p>如何确定是具名挂载和匿名挂载，还是指定路径挂载</p>
<blockquote>
<p>-v 容器内路径 #匿名挂载 #docker volume ls<br>-v 卷名:容器内路径 #具名挂载 #docker volume ls<br>-v &#x2F;宿主机路径:容器内路径 #指定路径挂载 #查看 docker inspect 容器id 查看Mounts</p>
</blockquote>
<h3 id="进入数据卷容器"><a href="#进入数据卷容器" class="headerlink" title="进入数据卷容器"></a>进入数据卷容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it db_data /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者 通过挂载的db1 进入</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**在通过**cd db_data**进入到数据卷里面**同时在重新打开一个窗口</p>
<p>注：db_data这个数据卷容器不能随便关，如果关了，其他挂载了db_data里面数据卷的容器就会用不了</p>
<h3 id="利用数据卷容器来迁移数据"><a href="#利用数据卷容器来迁移数据" class="headerlink" title="利用数据卷容器来迁移数据"></a><strong>利用数据卷容器来迁移数据</strong></h3><p><strong>1.备份</strong></p>
<p>使用下面的命令来备份dbdata数据卷容器内的数据卷：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --volumes-from dbdata -v $(<span class="built_in">pwd</span>):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span></span><br></pre></td></tr></table></figure>

<p>首先利用ubuntu镜像创建了一个容器worker。</p>
<p>使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷(即dbdata数据卷),</p>
<p>使用-v  $(pwd):&#x2F;backup参数来挂载本地的当前目录到worker容器的&#x2F;backup目录。</p>
<p>worker容器启动后</p>
<p>使用了tar cvf  &#x2F;backup&#x2F;backup.tar &#x2F;dbdata命令来将&#x2F;dbdata下内容备份为容器内的&#x2F;backup&#x2F;backup.tar，即宿主主机当前目录下的backup.tar</p>
<p><strong>2.恢复</strong></p>
<p>如果要将数据恢复到一个容器，可以按照下面的步骤操作。</p>
<p>首先创建一个带有数据卷的容器dbdata2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>然后创建另一个新的容器，挂载dbdata2的容器，并使用untar解压备份文件到所挂载的容器卷中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup --name worker ubuntu bash</span></span><br><span class="line"></span><br><span class="line">cd /dbdata</span><br><span class="line"></span><br><span class="line">tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>



<h1 id="Docker端口映射和数据互联"><a href="#Docker端口映射和数据互联" class="headerlink" title="Docker端口映射和数据互联"></a>Docker端口映射和数据互联</h1><p>在实践中，经常会碰到需要多个服务组件容器共同协作的情况，这往往需要多个容器之间能够互相访问到对方的服务。<br>Docker除了通过网络访问外，还提供了两个很方便的功能来满足服务访问的基本需求：</p>
<ol>
<li>一个是允许映射容器内应用的服务端口到本地宿主主机；</li>
<li>另一个是互联机制实现多个容器间通过容器名来快速访问;</li>
</ol>
<h2 id="端口映射实现容器访问"><a href="#端口映射实现容器访问" class="headerlink" title="端口映射实现容器访问"></a>端口映射实现容器访问</h2><p>6.1.1 从外部访问容器应用（-P&#x2F;-p）<br>在启动容器的时候，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。亦可使用Dockerfile文件中的EXPOSE指令来配置。<br>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过-P或-p参数来指定端口映射。当使用-P（大写的）标记时，Docker会随机映射一个端口到内部容器开放的网络端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:80 -it ubuntu /bin/bash</span><br><span class="line">docker run -it -d --name u4 -p 17000:7000 ubuntu:20.04</span><br></pre></td></tr></table></figure>

<p>端口映射支持的格式：<br>ip:hostport:containerport #指定ip、指定宿主机port、指定容器port<br>ip::containerport #指定ip、未指定宿主机port（随机）、指定容器port<br>hostport:containerport #未指定ip、指定宿主机port、指定容器port</p>
<h3 id="端口的映射五种方法"><a href="#端口的映射五种方法" class="headerlink" title="端口的映射五种方法"></a>端口的映射五种方法</h3><p><strong>一、将容器暴露的所有端口，都随机映射到宿主机上。</strong><br>例如：（不推荐使用）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>二、将容器指定端口随机映射到宿主机一个端口上。</strong><br>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P 80 -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>以上指令会将容器的80端口随机映射到宿主机的一个端口上。<br><strong>三、将容器指定端口指定映射到宿主机的一个端口上。</strong><br>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:80 -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>以上指令会将容器的80端口映射到宿主机的8000端口上。<br><strong>四、将容器ip和端口，随机映射到宿主机上。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P 192.168.0.100::80 -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>以上指令会将容器的ip192.168.0.100和80端口，随机映射到宿主机的一个端口上。<br><strong>五、将容器ip和端口，指定映射到宿主机上。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 192.168.0.100:8000:80 -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>以上指令会将容器的ip192.168.0.100和80端口，映射到宿主机的8000端口。<br>示例：<br>将nginx的80端口映射到宿主机的800端口上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it -p 800:80 nginx</span><br></pre></td></tr></table></figure>
<p>查看映射端口配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port container_ID #容器ID</span><br></pre></td></tr></table></figure>
<p>结果输出</p>
<blockquote>
<p>80&#x2F;tcp -&gt; 0.0.0.0:800</p>
</blockquote>
<h2 id="docker容器互联"><a href="#docker容器互联" class="headerlink" title="docker容器互联"></a>docker容器互联</h2><p>同一个宿主机上的多个docker容器之间如果想进行通信有三种方式：</p>
<ol>
<li>通过使用容器的ip地址来通信【这样会导致ip地址的硬编码，不方便迁移，并且容器重启后ip地址会改变，除非使用固定的ip】</li>
<li>通过宿主机的ip加上容器暴露出的端口号来通信【这样的通信方式比较单一，只能依靠监听在暴露出的端口的进程来进行有限的通信】</li>
<li>通过docker的link机制可以通过一个name来和另一个容器通信，link机制方便了容器去发现其它的容器并且可以安全的传递一些连接信息给其它的容器。</li>
</ol>
<h3 id="docker-–link"><a href="#docker-–link" class="headerlink" title="docker –link"></a>docker –link</h3><p>docker –link 使用了link机制后，可以通过指定的名字来和目标容器通信，这其实是通过给&#x2F;etc&#x2F;hosts中加入名称和IP的解析关系来实现的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建mysql容器</span></span><br><span class="line">docker run -dit --restart=always --name=mysql5 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 hub.c.163.com/library/mysql:latest </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql容器ip</span></span><br><span class="line">docker inspect mysql5 | grep -i ipaddr</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装一个操作系统容器,通过ip连接mysql容器</span></span><br><span class="line">docker run -it --restart=always --name=centos7 hub.c.163.com/library/centos:latest ping 172.17.0.4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过--<span class="built_in">link</span> 关联mysql容器</span></span><br><span class="line">docker run -it --restart=always --name=c7 --link mysql5:mysql hub.c.163.com/library/centos:latest ping mysql</span><br><span class="line"></span><br><span class="line">docker exec -it c7 /bin/bash</span><br></pre></td></tr></table></figure>



<p>使用docker –link需要注意以下几点：</p>
<ol>
<li>使用link选项建立的容器所链接的主机需要在运行状态</li>
<li>使用link选项建立的容器运行时需要所链接的容器也必须是运行状态</li>
<li>使用link选项链接的主机ip不需要固定，因为每次新建容器都会检查所链接容器的ip，在&#x2F;etc&#x2F;hosts里生成新的alias 名称对应的ip</li>
</ol>
<h3 id="docker五种基础网络类型"><a href="#docker五种基础网络类型" class="headerlink" title="docker五种基础网络类型"></a>docker五种基础网络类型</h3><p><strong>bridge</strong>: 默认类型，桥接到宿主机docker0的网络，类似于VM的Nat模式。</p>
<p><strong>host</strong>:host类型，使用宿主机网络，网络性能最高。</p>
<p><strong>none</strong>: 没有网络，该容器不能上外网。</p>
<p><strong>container</strong>:容器类型，使用其它容器的共享网络，这在K8S中频繁使用。比如同一个Pod中可以有多个容器共存。</p>
<p><strong>network</strong>: 自定义网络，我们可以使用docker network create创建自定义网络。    </p>
<p>温馨提示:<br>    (1)从严格意义上来说docker就只有3种基础网络类型，分别为bridge，host和none;<br>    (2)其中container和network本质上都是基于上述3种基础网络类型哟;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker102 ~]# docker network ls</span><br><span class="line">NETWORK ID NAME DRIVER SCOPE</span><br><span class="line">07f2bc765655 bridge bridge local</span><br><span class="line">7700940c7cc1 host host local</span><br><span class="line">94e6ae6d5cc7 none null local</span><br></pre></td></tr></table></figure>

<h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@docker102 ~]# docker network ls</span><br><span class="line"> 2 NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line"> 3 07f2bc765655   bridge    bridge    local</span><br><span class="line"> 4 7700940c7cc1   host      host      local</span><br><span class="line"> 5 94e6ae6d5cc7   none      null      local</span><br><span class="line"> 6 [root@docker102 ~]# docker network  create -d bridge --subnet 172.28.0.0/16 --gateway 172.28.0.254 zhanghe_network</span><br><span class="line"> 7 aa69afcc15774b47d1c59367b961658a928b840c445b926fae6fa756621c721c</span><br><span class="line"> 8 [root@docker102 ~]# docker container run -itd --name zhanghe_net_docker --network zhanghe_network  -p 81:80 nginx:1.20.1 </span><br><span class="line"> 9 9dd3d68e86c842ad6e7e0de6152bfe8a7f5367564e9bcd47952a2d079e68cbf2</span><br><span class="line">10 [root@docker102 ~]# docker container inspect --format=&quot;&#123;&#123;.NetworkSettings.Networks.zhanghe_network.IPAddress&#125;&#125;&quot; `docker container ls -lq`</span><br><span class="line">11 172.28.0.1</span><br><span class="line">12 [root@docker102 ~]# curl 172.28.0.1</span><br><span class="line">13 &lt;!DOCTYPE html&gt;</span><br><span class="line">14 &lt;html&gt;</span><br><span class="line">15 &lt;head&gt;</span><br><span class="line">16 &lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">17 &lt;style&gt;</span><br><span class="line">18     body &#123;</span><br><span class="line">19         width: 35em;</span><br><span class="line">20         margin: 0 auto;</span><br><span class="line">21         font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">22     &#125;</span><br><span class="line">23 &lt;/style&gt;</span><br><span class="line">24 &lt;/head&gt;</span><br><span class="line">25 &lt;body&gt;</span><br><span class="line">26 &lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">27 &lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">28 working. Further configuration is required.&lt;/p&gt;</span><br><span class="line">29 </span><br><span class="line">30 &lt;p&gt;For online documentation and support please refer to</span><br><span class="line">31 &lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">32 Commercial support is available at</span><br><span class="line">33 &lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line">34 </span><br><span class="line">35 &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">36 &lt;/body&gt;</span><br><span class="line">37 &lt;/html&gt;</span><br><span class="line">38 [root@docker102 ~]# </span><br></pre></td></tr></table></figure>



<h3 id="自定义macvlan网络"><a href="#自定义macvlan网络" class="headerlink" title="自定义macvlan网络"></a>自定义macvlan网络</h3><p>优点:<br>    (1)docker原生支持，无需安装额外插件，配置起来相对简单。<br>    (2)适合小规模docker环境，例如只有1-3台，如果服务器过多，手动分配IP地址可能会无形之间增加工作量;</p>
<p>缺点:<br>    (1)需要手动分配IP地址，如果让其自动分配IP地址可能会存在多个主机自动分配的IP地址冲突的情况，到时候还需要人工介入维护;<br>    (2)本机相同网络(本案例为”oldboyedu_macvlan”)的容器之间相互通信没问题，跨主机之间的容器进行通信也没问题，但容器无法与宿主机之间进行通信，也无法连接到外网<br>温馨提示:<br>    如果非要使用macvlan，我们需要手动分配IP地址，无法联网的问题，只需要使用”docker network connect”重新分配一块网卡即可解决。</p>
<h1 id="Docker文件夹挂载"><a href="#Docker文件夹挂载" class="headerlink" title="Docker文件夹挂载"></a>Docker文件夹挂载</h1><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p><em>Dockerfile</em>是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成映像。</p>
<p><code>docker build</code>命令用于从Dockerfile构建映像。可以在<code>docker build</code>命令中使用<code>-f</code>标志指向文件系统中任何位置的Dockerfile。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -f /path/to/a/Dockerfile</span></span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile文件说明"><a href="#Dockerfile文件说明" class="headerlink" title="Dockerfile文件说明"></a>Dockerfile文件说明</h2><p>说明不区分大小写，但必须遵循建议使用大写字母的约定。</p>
<p>Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是<em>FROM</em>。</p>
<p>一个声明以<code>＃</code>字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</p>
<p>在这里列出了一些常用的说明。</p>
<p><strong>FROM</strong></p>
<p>该指令用于设置后续指令的基本映像。有效的Dockerfile必须使用<code>FROM</code>作为其第一条指令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>LABEL</strong></p>
<p>可以为映像添加标签来组织项目的映像。需要使用<em>LABEL</em>指令设置映像的标签。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL vendorl = &quot;YiiBai&quot;</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>RUN</strong></p>
<p>该指令用于执行当前映像的任何命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &#x27;source $HOME/.bashrc; echo $HOME&#x27;</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong></p>
<p>这用于执行映像的应用程序。应该以下列形式总是使用<em>CMD</em> - </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;?]</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p>这是使用<em>CMD</em>的首选方法。Dockerfile文件中只能有一个<em>CMD</em>。如果使用多个<em>CMD</em>，则只会执行最后一个<em>CMD</em>。</p>
<p><strong>COPY</strong></p>
<p>该指令用于将来自源的新文件或目录复制到目的地的容器的文件系统。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY abc/ /xyz</span><br><span class="line">Shell</span><br></pre></td></tr></table></figure>

<p><strong>规则</strong></p>
<ul>
<li><code>source</code>路径必须在构建的上下文之内。无法使用<code>COPY ../something /something</code>，因为docker构建的第一步是将上下文目录(和子目录)发送到docker守护程序。</li>
<li>如果<code>source</code>是目录，则会复制目录的全部内容，包括文件系统元数据。</li>
</ul>
<p><strong>WORKDIR</strong></p>
<p><em>WORKDIR</em>用于为<em>Dockerfile</em>中的<code>RUN</code>，<code>CMD</code>和<code>COPY</code>指令设置工作目录。如果工作目录不存在，它默认将会创建。</p>
<p>我们可以在<em>Dockerfile</em>文件中多次使用<code>WORKDIR</code>。</p>
<h1 id="docer-K8S"><a href="#docer-K8S" class="headerlink" title="docer K8S"></a>docer K8S</h1><p>Kubernetes是Google团队发起并维护的开源容器集群管理系统，支持如Docker等容器技术。类似Docker Swarm，使用Kubernetes，用户可以轻松搭建和管理一个私有容器云。</p>
<p>Kubernetes是Google公司于2014年基于内部集群管理系统Borg开源的容器集群管理项目。该项目基于Go语言实现，试图为基于容器的应用部署和管理打造一套强大并且易用的管理平台。Kubernetes自开源之日起就吸引了众多公司和容器技术爱好者的关注，是目前容器集群管理最优秀的开源项目之一。已有Microsoft、RedHat、IBM、Docker、Mesosphere、CoreOS以及SaltStack等公司加入了Kubernetes社区。</p>
<p>Kubernetes的前身（Borg系统）在Google内部已经应用了十几年，积累了大量来自生产环境的宝贵实践经验。在设计Kubernete的时候，团队也很好地结合了来自社区的想法。</p>
<p>正是因为这些积累，作为一套分布式应用容器集群系统，Kubernetes拥有鲜明的技术优势：</p>
<p>优秀的API设计，以及简洁高效的架构设计，主要组件个数很少，彼此之间通过接口调用；基于微服务模式的多层资源抽象模型，兼顾灵活性与可操作性，提出的Pod模型被许多平台借鉴；可拓展性好，模块化容易替换，伸缩能力极佳，1.2.0版本单集群支持1000个节点，同时运行30000个Pods；自动化程度高，真正实现“所得即所需”，用户通过模板声明服务后，生命周期都是自动化管理；部署支持多种环境，包括虚拟机、裸机部署，还很好地支持常见云平台，包括AWS、GCE等；支持丰富的运维工具，方便用户对集群进行性能测试、问题检查和状态监控；自带控制台、客户端命令等工具，允许用户通过多种方式与kubernetes集群进行交互。</p>
<p>基于Kubernetes，可以很容易地实现一套PaaS，比如Openshift和Deis。</p>
<p>2015年7月发布的1.0版本是Kubernetes的第一个正式版本，标志着核心功能已经逐渐成熟稳定，可以正式投入生产环境使用。</p>
<p>2016年3月发布的1.2.0版本，在性能、稳定性和可管理性上都有了重大的优化和升级，包括对多可用域的支持、监控服务增强、上千物理节点的支持等令人振奋的特性。</p>
<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h1><p>使用 Dockerfile 定义应用程序的环境</p>
<p>　　使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起行</p>
<p>　　最后，执行 docker-compose up 命令来启动并运行整个应用程序</p>
<p>　　<strong>为什么需要docker-compose</strong></p>
<p>　　Docker帮助我们解决服务的打包安装的问题，随着而来的问题就是服务过多的带来如下问题：</p>
<p>　　1、多次使用 Dockerfile、Build、Image 命令或者 DockerHub 拉取 Image;</p>
<p>　　2、需要创建多个Container，多次编写启动命令;</p>
<p>　　3、Container互相依赖的如何进行管理和编排;</p>
<p>　　当我们服务数量增多的时候，上面三个问题就会更加的被放大，如果这三个问题不解决，其实从虚拟机到容器化除了机器减少一些浪费以外，好像没有更多的变化<br>　　Docker有没有什么好的方法，可以让我们通过一个配置就搞定容器编排和运行呢?</p>
<p>　　这个时候Docker Compose就站出来了</p>
<p>　　<strong>Docker Compose可以做到以下几点：</strong></p>
<p>①提供工具用于定义和运行多个docker容器应用;</p>
<p>②使用yaml文件来配置应用服务(docker-compse.yml);</p>
<p>③可以通过一个简单的命令docker-compse up可以按照依赖关系启动所有服务;</p>
<p>④可以通过一个简单的命令docker-compose down停止所有服务;</p>
<p>⑤当一个服务需要的时候，可以很简单地通过–scale进行扩容;</p>
<p><strong>Docker Compose有以下特征:</strong></p>
<p>更高的可移植性，Docker Compose仅需一个docker-compse up可以完成按照依赖关系启动所有服务，然后使用docker-compose down轻松将其拆解。帮助我们更轻松地部署复杂的应用程序;单个主机上的多个隔离环境，Compose可以使用项目名称将环境彼此隔离，这带可以在一台计算机上运行同一环境的多个副本，它可以防止不同的项目和服务相互干扰;</p>
<h2 id="docker-compose-安装"><a href="#docker-compose-安装" class="headerlink" title="docker compose 安装"></a>docker compose 安装</h2><p>pip安装</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下载安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载docker-compose文件</span></span><br><span class="line"></span><br><span class="line">mv docker-compose /usr/local/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件复制到/usr/local/bin环境变量下面</span></span><br><span class="line"></span><br><span class="line">chmod a+x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给他一个执行权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https://links.jianshu.com/go?to=https%3A%2F%2Fdownload.docker.com%2Flinux%2Fcentos%2F7%2Fx86_64%2Fstable%2FPackages%2Fdocker-compose-plugin-2.17.3-1.el7.x86_64.rpm</span><br><span class="line">https://docs.docker.com/compose/install</span><br><span class="line">https://docs.docker.com/compose/compose-file/compose-file-v3</span><br></pre></td></tr></table></figure>



<h2 id="compose-YAML文件编写"><a href="#compose-YAML文件编写" class="headerlink" title="compose YAML文件编写"></a>compose YAML文件编写</h2><p>1、Compose文件是一个定义服务，网络和卷的YAML文件</p>
<p>2、Compose文件的默认文件名为docker-compose.yml</p>
<p>提示：您可以对此文件使用.yml或.yaml扩展名， 他们都工作与docker运行一样，默认情况下，Dockerfile中指定的选项(例如，CMD，EXPOSE，VOLUME，ENV)都被遵守，你不需要在docker-compose.yml中再次指定它们同时你可以使用类似Bash的$ {VARIABLE} 语法在配置值中使用环境变量</p>
<h3 id="YAML文件格式"><a href="#YAML文件格式" class="headerlink" title="YAML文件格式&#96;"></a>YAML文件格式&#96;</h3><ol>
<li><p>YAML是一种标记性语言, 它可以很直观的展示数据序列化格式,可读性高.</p>
</li>
<li><p>类似于json数据描述语言.</p>
</li>
<li><p>YAML数据结构通过缩进来表示,连续项目通过减号表示,键值对用冒号分隔,数组使用总括号[]括起来,bash用花括号{}括起来.</p>
</li>
<li><p>不支持制表符TAB缩进,只能使用空格缩进</p>
</li>
<li><p>开头通常缩进2个空格</p>
</li>
<li><p>字符后缩进一个空格(如冒号,逗号,横杠后须加空格)</p>
</li>
<li><p>使用#号表示注释</p>
</li>
<li><p>如果包含特殊字符用单引号&#96; ‘ ‘ 标记为普通字符,用双引号表示特殊字符本身的意思</p>
</li>
</ol>
<p>布尔值必须使用双引号””括起来</p>
<ol>
<li>YAML 区分大小写</li>
</ol>
<h3 id="YAML常用命令"><a href="#YAML常用命令" class="headerlink" title="YAML常用命令"></a>YAML常用命令</h3><table>
<thead>
<tr>
<th>字段</th>
<th>docker指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>build</td>
<td>build</td>
<td>指定Drockerfile文件名（要指定的Dockerfile文件需要在build标签的子级标签中用dockefile标签指定）</td>
</tr>
<tr>
<td>dockerfile</td>
<td>dockerfile</td>
<td>构建镜像上下文路径</td>
</tr>
<tr>
<td>context</td>
<td></td>
<td>可以是dockerfile路径，或者时执行git仓库的url地址</td>
</tr>
<tr>
<td>images</td>
<td>run</td>
<td>指定镜像（已存在）</td>
</tr>
<tr>
<td>command</td>
<td></td>
<td>执行命令，会覆盖容器启动后默认执行的命令（会覆盖dockefile中的CMD指令）</td>
</tr>
<tr>
<td>container_name</td>
<td>–name</td>
<td>指定容器名称，由于容器名称是唯一的，如果指定自定义名称，则无法scale指定容器数量。</td>
</tr>
<tr>
<td>deploy</td>
<td></td>
<td>指定部署和运行服务相关配置，只能在swarm模式使用</td>
</tr>
<tr>
<td>environment</td>
<td>-e</td>
<td>添加环境变量</td>
</tr>
<tr>
<td>networks</td>
<td>–network</td>
<td>加入网络，引用顶级networks下条目</td>
</tr>
<tr>
<td>network-mode</td>
<td></td>
<td>设置容器的网络模式</td>
</tr>
<tr>
<td>ports</td>
<td>-p</td>
<td>暴露容器端口，与-p相同，但是端口不能低于60</td>
</tr>
<tr>
<td>volumes</td>
<td>-v</td>
<td>挂载一个宿主机目录或命令卷到容器，命令卷要在顶级volumes定义卷名称</td>
</tr>
<tr>
<td>volumes_from</td>
<td></td>
<td>从另一个服务或容器挂载卷，可选参数：ro和rw（仅版本‘2’支持）</td>
</tr>
<tr>
<td>hostname</td>
<td></td>
<td>在容器内设置内核参数</td>
</tr>
<tr>
<td>links</td>
<td>–link</td>
<td>连接诶到另一个容器，- 服务名称[ : ]</td>
</tr>
<tr>
<td>privileged</td>
<td></td>
<td>用来给容器root权限，注意是不安全的，true</td>
</tr>
<tr>
<td>restart</td>
<td>–restart</td>
<td>重启策略，定义是否重启容器1、no，默认策略，在容器退出时不重启容器2、on-failure，在容器非正常退出时（退出状态非0），才会重启容器3、on-failure：3 在容器非正常退出时，重启容器，最多重启3次4、always，在容器退出时总是重启容器，5、unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器。</td>
</tr>
<tr>
<td>depends_on</td>
<td></td>
<td>此标签用于解决容器的依赖，启动先后问题。如启动应用容器，需要先启动数据库容器。php:depends_on:- apache- mysql</td>
</tr>
</tbody></table>
<p><strong>build</strong></p>
<p>该参数指定Dockerfile文件的路径，Docker Compose会通过Dockerfile构建并生成镜像，然后使用该镜像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build: <span class="comment">#构建的地址context: /oldboyedu/dockerfile/docker-composedockerfile: Dockerfile</span></span><br></pre></td></tr></table></figure>

<p>　<strong>image</strong></p>
<p>指定启动容器的镜像，可以是镜像仓库&#x2F;标签或者镜像id(或者id的前一部分)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: centos</span><br></pre></td></tr></table></figure>

<p>如果镜像不存在，Compose将尝试从官方镜像仓库将其pull下来，如果你还指定了build，在这种情况下，它将使用指定的build选项构建它，并使用image指定的名字和标记对其进行标记</p>
<p><strong>container_name</strong></p>
<p>指定一个自定义容器名称，而不是生成的默认名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-compose-centos</span><br></pre></td></tr></table></figure>

<p>　由于Docker容器名称必须是唯一的，因此如果指定了自定义名称，则无法将服务扩展到多个容器</p>
<p><strong>volumes</strong></p>
<p>　卷挂载路径设置。可以设置宿主机路径 (HOST:CONTAINER) 或加上访问模式 (HOST:CONTAINER:ro),挂载数据卷的默认权限是读写(rw)，可以通过ro指定为只读</p>
<p>你可以在主机上挂载相对路径，该路径将相对于当前正在使用的Compose配置文件的目录进行扩展。相对路径应始终以 . 或者 .. 开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes: <span class="comment"># 只需指定一个路径，让引擎创建一个卷 - /oldboyedu/data/docker-compose # 指定绝对路径映射 - /opt/data:/oldboyedu/data/docker-compose # 相对于当前compose文件的相对路径 - ./cache:/oldboyedu/data/docker-compose # 用户家目录相对路径 - ~/configs:/oldboyedu/data/docker-compose:ro # 命名卷 - datavolume:/oldboyedu/data/docker-compose</span></span><br></pre></td></tr></table></figure>

<p>但是，如果要跨多个服务并重用挂载卷，请在顶级volumes关键字中命名挂在卷，但是并不强制，如下的示例亦有重用挂载卷的功能，但是不提倡</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span>services:web1:  build: ./web/  volumes:     - ../code:/oldboyedu/data/docker-composeweb2:  build: ./web/  volumes:     - ../code:/oldboyedu/data/docker-compose</span><br></pre></td></tr></table></figure>

<p>注意：通过顶级volumes定义一个挂载卷，并从每个服务的卷列表中引用它， 这会替换早期版本的Compose文件格式中volumes_from</p>
<p><strong>links</strong></p>
<p>链接到另一个服务中的容器请指定服务名称和链接别名(SERVICE：ALIAS)，或者仅指定服务名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web:links:  - db  - db:database  - redis</span><br></pre></td></tr></table></figure>

<p>在当前的web服务的容器中可以通过链接的db服务的别名database访问db容器中的数据库应用，如果没有指定别名，则可直接使用服务名访问链接不需要启用服务进行通信 - 默认情况下，任何服务都可以以该服务的名称到达任何其他服务(实际是通过设置&#x2F;etc&#x2F;hosts的域名解析，从而实现容器间的通信。故可以像在应用中使用localhost一样使用服务的别名链接其他容器的服务，前提是多个服务容器在一个网络中可路由联通)links也可以起到和depends_on相似的功能，即定义服务之间的依赖关系，从而确定服务启动的顺序</p>
<p><strong>external_links</strong></p>
<p>链接到docker-compose.yml 外部的容器，甚至并非 Compose 管理的容器，参数格式跟 links 类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_links:- redis_1- project_db_1:mysql- project_db_1:postgresql</span><br></pre></td></tr></table></figure>

<p><strong>expose</strong></p>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问仅可以指定内部端口为参数</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">expose:</span>- <span class="string">&quot;3000&quot;</span>- <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>ports</strong></p>
<p>　暴露端口信息常用的简单格式：使用宿主：容器 (HOST:CONTAINER)格式或者仅仅指定容器的端口(宿主将会随机选择端口)都可以</p>
<p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式</p>
<p>简单的短格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">    - <span class="string">&quot;3000&quot;</span></span><br><span class="line">    - <span class="string">&quot;3000-3005&quot;</span></span><br><span class="line">    - <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    - <span class="string">&quot;9090-9091:8080-8081&quot;</span></span><br><span class="line">    - <span class="string">&quot;49100:22&quot;</span></span><br><span class="line">    - <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br><span class="line">    - <span class="string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span></span><br><span class="line">    - <span class="string">&quot;6060:6060/udp&quot;</span></span><br></pre></td></tr></table></figure>

<p>在v3.2中ports的长格式的语法允许配置不能用短格式表示的附加字段长格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports: - target: <span class="number">80</span>  published: <span class="number">8080</span>  protocol: tcp  mode: host</span><br></pre></td></tr></table></figure>

<p><img src="/docker%20%E4%BB%8B%E7%BB%8D.assets/8326cffc1e178a82d1a4bb90816f4186a877e8da.png" alt="img"></p>
<p><strong>restart</strong></p>
<p>no是默认的重启策略，在任何情况下都不会重启容器指定为always时，容器总是重新启动，如果退出代码指示出现故障错误，则on-failure将重新启动容器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: <span class="string">&quot;no&quot;</span>restart: alwaysrestart: on-failurerestart: unless-stopped</span><br></pre></td></tr></table></figure>

<p><strong>environment</strong></p>
<p>添加环境变量。你可以使用数组或字典两种形式。任何布尔值; true，false，yes，no需要用引号括起来，以确保它们不被YML解析器转换为True或False只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment:RACK_ENV: developmentSHOW: <span class="string">&#x27;true&#x27;</span>SESSION_SECRET:environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET</span><br></pre></td></tr></table></figure>

<p>注意：如果你的服务指定了build选项，那么在构建过程中通过environment定义的环境变量将不会起作用。将使用build的args子选项来定义构建时的环境变量</p>
<p><strong>pid</strong></p>
<p>将PID模式设置为主机PID模式吗， 这就打开了容器与主机操作系统之间的共享PID地址空间使用此标志启动的容器将能够访问和操作裸机的命名空间中的其他容器，反之亦然。即打开该选项的容器可以相互通过进程 ID 来访问和操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>dns</strong></p>
<p>　配置 DNS 服务器。可以是一个值，也可以是一个列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns: <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>dns:- <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span> - <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br></pre></td></tr></table></figure>



<h3 id="docker-compose操作指令"><a href="#docker-compose操作指令" class="headerlink" title="docker-compose操作指令"></a>docker-compose操作指令</h3><p> 运行这些命令需要结合docker-compse一起使用并且必须要在含有docker-compose.yaml文件的目录中才能运行.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>build</td>
<td>重构服务</td>
</tr>
<tr>
<td>ps</td>
<td>列出容器</td>
</tr>
<tr>
<td>up</td>
<td>创建和启动容器</td>
</tr>
<tr>
<td>exec</td>
<td>在容器里面执行命令</td>
</tr>
<tr>
<td>scale</td>
<td>指定一个服务容器启动数量</td>
</tr>
<tr>
<td>top</td>
<td>显示运行容器的进行</td>
</tr>
<tr>
<td>log</td>
<td>查看服务容器的输0出</td>
</tr>
<tr>
<td>down</td>
<td>删除容器,网络,数据卷和镜像</td>
</tr>
<tr>
<td>start&#x2F;stop&#x2F;restart</td>
<td>启动,停止,重启</td>
</tr>
</tbody></table>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Docker-compose.yml 文件配置指令参考</span></span><br><span class="line"><span class="string">version：指定此yml文件基于的compose的版本</span></span><br><span class="line"></span><br><span class="line">	<span class="string">services：指定创建容器的服务选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务名：例如nginx等</span></span><br><span class="line">	<span class="string">hostname：容器主机名</span></span><br><span class="line">	<span class="string">build</span> <span class="string">：指定构建镜像上下文路径</span></span><br><span class="line">	<span class="string">context：上下文路径</span></span><br><span class="line">	<span class="string">dockerfile：指定构建镜像的</span> <span class="string">Dockerfile</span> <span class="string">文件名</span></span><br><span class="line">	<span class="string">ports：暴露容器端口，与-p相同，但端口不能低于60；例如：-</span> <span class="number">1234</span><span class="string">:80</span></span><br><span class="line">	<span class="string">networks：加入顶级networks下配置的网络</span></span><br><span class="line">	<span class="string">deploy：指定部署和运行服务相关配置，只能在Swarm模式使用</span></span><br><span class="line">	<span class="string">volumes：挂载宿主机路径或命令卷</span></span><br><span class="line">	<span class="string">image：指定容器运行的镜像</span></span><br><span class="line">	<span class="string">command：执行命令，覆盖默认命令</span></span><br><span class="line">	<span class="string">container_name：指定容器名称，由于容器名称是唯一的，如果指定自定义名称，则无法scale（扩展）</span></span><br><span class="line">	<span class="string">environment：添加环境变量</span></span><br><span class="line">	<span class="string">restart：重启策略，重启策略是no，always，no-failure，unless-stoped</span></span><br><span class="line">	<span class="literal">no</span><span class="string">，默认策略，在容器退出时不重启容器。</span></span><br><span class="line">	<span class="string">on-failure，在容器非正常退出时（退出状态非0），才会重启容器。</span></span><br><span class="line">	<span class="string">on-failure:3，在容器非正常退出时重启容器，最多重启3次。</span></span><br><span class="line">    <span class="string">always，在容器退出时总是重启容器。</span></span><br><span class="line">	<span class="string">unless-stopped，在容器退出时总是重启容器，但是不考虑在</span> <span class="string">Docker守护进程启动时就已经停止了的容器。</span></span><br><span class="line">	<span class="string">networks：配置网络，指定网卡设备等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="mysql一主一从"><a href="#mysql一主一从" class="headerlink" title="mysql一主一从"></a>mysql一主一从</h1><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>MySQL 的主从复制工作过程大致如下：</p>
<ol>
<li>从库生成<strong>两个线程</strong>，一个 I&#x2F;O 线程，一个 SQL 线程；</li>
<li>I&#x2F;O 线程去请求主库的 binlog，并将得到的 binlog 日志<strong>写到</strong> relay log(中继日志) 文件中；</li>
<li>主库会<strong>生成</strong>一个 log dump 线程，用来给从库 I&#x2F;O 线程传 binlog；</li>
<li>SQL 线程会读取 relay log 文件中的日志，并<strong>解析</strong>成具体操作，来实现主从的操作一致，而最终数据一致；</li>
</ol>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>MySQL 建立请求的主从的详细流程如下：</p>
<ol>
<li>当从服务器连接主服务器时，主服务器会创建一个 log dump 线程，用于发送 binlog 的内容。在读取 binlog 的内容的操作中，会对象主节点上的 binlog <strong>加锁</strong>，当读取完成并发送给从服务器后解锁。</li>
<li>当从节点上执行 <code>start slave</code> 命令之后，从节点会创建一个 IO 线程用来连接主节点，请求主库中<strong>更新</strong> binlog。IO 线程接收主节点 binlog dump 进程发来的更新之后，保存到 relay-log 中。</li>
<li>从节点 SQL 线程负责读取 realy-log 中的内容，<strong>解析</strong>成具体的操作执行，最终保证主从数据的一致性。</li>
</ol>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>MySQL 主从复制支持两种不同的日志格式，这两种日志格式也对应了各自的复制方式。当然也有二者相结合的混合类型复制。</p>
<h4 id="语句复制"><a href="#语句复制" class="headerlink" title="语句复制"></a>语句复制</h4><p>基于语句的复制相当于<strong>逻辑复制</strong>，即二进制日志中记录了操作的语句，通过这些语句在从数据库中重放来实现复制。</p>
<p>这种方式简单，二进制文件小，传输带宽占用小。但是基于语句更新依赖于其它因素，比如插入数据时利用了时间戳。</p>
<p>因此在开发当中，我们应该尽量将业务逻辑逻辑放在<strong>代码层</strong>，而不应该放在 MySQL 中，不易拓展。</p>
<p><em>特点</em>：</p>
<ul>
<li>传输效率高，减少延迟。</li>
<li>在从库更新不存在的记录时，语句赋值不会失败。而行复制会导致失败，从而更早发现主从之间的不一致。</li>
<li>设表里有一百万条数据，一条sql更新了所有表，基于语句的复制仅需要发送一条sql，而基于行的复制需要发送一百万条更新记录</li>
</ul>
<h4 id="行数据复制"><a href="#行数据复制" class="headerlink" title="行数据复制"></a>行数据复制</h4><p>基于行的复制相当于<strong>物理复制</strong>，即二进制日志中记录的实际更新数据的每一行。</p>
<p>这样导致复制的压力比较大，日志占用的空间大，传输带宽占用大。但是这种方式比基于语句的复制要更加<strong>精确</strong>。</p>
<p><em>特点</em>：</p>
<ul>
<li>不需要执行查询计划。</li>
<li>不知道执行的到底是什么语句。</li>
<li>例如一条更新用户总积分的语句，需要统计用户的所有积分再写入用户表。如果是基于语句复制的话，从库需要再一次统计用户的积分，而基于行复制就直接更新记录，无需再统计用户积分。</li>
</ul>
<h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><p>一般情况下，默认采用<strong>基于语句</strong>的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置主要要点如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 如果在双主复制结构中没有设置ID的话就会导致循环同步问题</span><br><span class="line">server_id=1</span><br><span class="line"></span><br><span class="line"># 即日志中记录的是语句还是行更新或者是混合 Row、Statement、Mixed</span><br><span class="line">binlog_format=mixed</span><br><span class="line"></span><br><span class="line"># 在进行n次事务提交以后，Mysql将执行一次fsync的磁盘同步指令。将缓冲区数据刷新到磁盘。</span><br><span class="line"># 为0的话由Mysql自己控制频率。</span><br><span class="line">sync_binlog=n</span><br><span class="line"></span><br><span class="line"># 为0的话，log buffer将每秒一次地写入log file中并且刷新到磁盘。</span><br><span class="line"># mysqld进程崩溃会丢失一秒内的所有事务。</span><br><span class="line"># 为1的话，每次事务log buffer会写入log file并刷新到磁盘。（较为安全）</span><br><span class="line"># 在崩溃的时候,仅会丢失一个事务。</span><br><span class="line"># 为2的话，每次事务log buffer会写入log file，但一秒一次刷新到磁盘</span><br><span class="line">innodb_flush_logs_at_trx_commit=0</span><br><span class="line"></span><br><span class="line"># 阻止从库崩溃后自动启动复制，给一些时间来修复可能的问题，</span><br><span class="line"># 崩溃后再自动复制可能会导致更多的问题。并且本身就是不一致的</span><br><span class="line">skip_slave_start=1 </span><br><span class="line"></span><br><span class="line"># 是否将从库同步的事件也记录到从库自身的bin-log中</span><br><span class="line"># 允许备库将重放的事件也记录到自身的二进制日志中去，可以将备库当做另外一台主库的从库</span><br><span class="line">log_slave_update </span><br><span class="line"></span><br><span class="line"># 日志过期删除时间，延迟严重的话会导致日志文件占用磁盘</span><br><span class="line">expire_logs_days=7</span><br></pre></td></tr></table></figure>

<h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>当主库的 TPS 并发较高的时候，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的<strong>处理速度</strong>。</p>
<p><em>解决方法</em>：</p>
<ul>
<li>网络方面：尽量保证主库和从库之间的<strong>网络稳定</strong>，延迟较小；</li>
<li>硬件方面：从库<strong>配置更好</strong>的硬件，提升随机写的性能；</li>
<li>配置方面：尽量使 MySQL 的操作在<strong>内存中完成</strong>，减少磁盘操作。或升级 MySQL5.7 版本使用并行复制；</li>
<li>建构方面：在事务中尽量对<strong>主库读写</strong>，其它非事务的读在从库。消除一部分<strong>延迟</strong>带来的数据库不一致。<strong>增加缓存</strong>降低一些从库的负载。</li>
</ul>
<h4 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h4><p>当主库宕机后，数据可能丢失。</p>
<p><em>解决方法</em>：</p>
<p>使用<strong>半同步</strong>复制，可以解决数据丢失的问题。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>MySQL 需要注意以下事项：</p>
<ul>
<li>MySQL 主从复制是 MySQL <strong>高可用性，高性能</strong>（负载均衡）的基础；</li>
<li>简单，灵活，部署<strong>方式多样</strong>，可以根据不同业务场景部署不同复制结构；</li>
<li>复制过程中应该时刻<strong>监控</strong>复制状态，复制出错或延时可能给系统造成影响；</li>
<li>MySQL 主从复制目前也存在一些问题，可以根据需要部署<strong>复制增强</strong>功能。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主从复制带来了很多好处，当我们的主服务器出现问题，可以<strong>切换</strong>到从服务器；可以进行数据库层面的<strong>读写分离</strong>；可以在从数据库上进行日常<strong>备份</strong>。还可以保证：</p>
<ol>
<li>数据更安全：做了<strong>数据冗余</strong>，不会因为单台服务器的宕机而丢失数据；</li>
<li>性能大大提升：一主多从，不同用户从不同数据库读取，<strong>性能提升</strong>；</li>
<li>扩展性更优：流量增大时，可以方便的<strong>增加</strong>从服务器，不影响系统使用；</li>
<li>负载均衡：一主多从相当于分担了主机任务，做了<strong>负载均衡</strong>。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>MySQL 主从复制集群功能使得 MySQL 数据库支持<strong>大规模高并发读写</strong>成为可能，同时有效地保护了物理服务器宕机场景的<strong>数据备份</strong>。</p>
<h4 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h4><p>将工作负载<strong>分发</strong>到各 Slave 节点上，从而提高系统性能。</p>
<p>在这个场景下，所有的写(write)和更新(update)操作都在 Master 节点上完成；所有的读( read)操作都在 Slave 节点上完成。通过<strong>增加更多</strong>的 Slave 节点，便能提高系统的读取速度。</p>
<h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h4><p>数据从 Master 节点复制到 Slave 节点上，在 Slave 节点上可以<strong>暂停</strong>复制进程。可以在 Slave 节点上<strong>备份</strong>与 Master 节点对应的数据，而不用影响 Master 节点的运行。</p>
<h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><p>实时数据可以在 Master 节点上创建，而分析这些数据可以在 Slave 节点上进行，并且不会对 Master 节点的性能产生影响。</p>
<h4 id="远距离数据分布"><a href="#远距离数据分布" class="headerlink" title="远距离数据分布"></a>远距离数据分布</h4><p>可以利用复制在远程主机上创建一份本地数据的<strong>副本</strong>，而不用持久的与Master节点连接。</p>
<h4 id="拆分访问"><a href="#拆分访问" class="headerlink" title="拆分访问"></a>拆分访问</h4><p>可以把几个不同的从服务器，根据公司的<strong>业务</strong>进行拆分。通过拆分可以帮助减轻主服务器的压力，还可以使数据库对外部用户浏览、内部用户业务处理及 DBA 人员的备份等<strong>互不影响</strong>。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.在数据卷目录中 创建两个文件夹  master worker 文件夹再各创建三个文件夹</span></span><br><span class="line">mkdir /opt/docker/mysql/master </span><br><span class="line">mkdir /opt/docker/mysql/master/log</span><br><span class="line">mkdir /opt/docker/mysql/master/data</span><br><span class="line">mkdir /opt/docker/mysql/master/cnf</span><br><span class="line">cp -r /opt/docker/mysql/master /opt/docker/mysql/worker</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.创建2个容器</span></span><br><span class="line">docker run -itd \</span><br><span class="line">-p 3333:3306 \</span><br><span class="line">--name master \</span><br><span class="line">--hostname master \</span><br><span class="line">-v /opt/docker/mysql/master/cnf:/etc/mysql/mysql.conf.d \</span><br><span class="line">-v /opt/docker/mysql/master/data:/var/lib/mysql \</span><br><span class="line">-v /opt/docker/mysql/master/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br><span class="line">     </span><br><span class="line">docker run -itd \</span><br><span class="line">-p 3334:3306 \</span><br><span class="line">--name worker \</span><br><span class="line">--link master \</span><br><span class="line">-v /opt/docker/mysql/worker/cnf/:/etc/mysql/mysql.conf.d \</span><br><span class="line">-v /opt/docker/mysql/worker/data:/var/lib/mysql \</span><br><span class="line">-v /opt/docker/mysql/worker/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------------------------------</span></span><br><span class="line">docker run -itd -p 3333:3306 --name mysqlmaster -v C:\Users\zy\Documents\docker\master\cnf:/etc/mysql/mysql.conf.d -v C:\Users\zy\Documents\docker\master\data:/var/lib/mysql -v C:\Users\zy\Documents\docker\master\log:/var/log/mysql -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -itd -p 3334:3306 --name mysqlworker -v C:\Users\zy\Documents\docker\worker\cnf:/etc/mysql/mysql.conf.d -v C:\Users\zy\Documents\docker\worker\data:/var/lib/mysql -v C:\Users\zy\Documents\docker\worker\log:/var/log/mysql -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">----------------------------------------</span></span><br><span class="line">docker run -itd \</span><br><span class="line">-p 3336:3306 \</span><br><span class="line">--name slave1 \</span><br><span class="line">-v /opt/mysql_server/slave/cnf/:/etc/mysql/mysql.conf.d \</span><br><span class="line">-v /opt/mysql_server/slave/data:/var/lib/mysql \</span><br><span class="line">-v /opt/mysql_server/slave/log:/var/log/mysql \</span><br><span class="line">--net mysql_net \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">-p 3335:3306 \</span><br><span class="line">--name master1 \</span><br><span class="line">-v /opt/mysql_server/master/cnf/:/etc/mysql/mysql.conf.d \</span><br><span class="line">-v /opt/mysql_server/master/data:/var/lib/mysql \</span><br><span class="line">-v /opt/mysql_server/master/mysqllog:/var/log/mysqld.log \</span><br><span class="line">--net mysql_net \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.进入容器,修改my.cnf 添加</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">修改主服务配置文件：vim /etc/my.cnf</span></span><br><span class="line"> [mysqld]</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">主服务器唯一ID</span></span><br><span class="line">server_id=1</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面两行最重要，下面的可以不配置# 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">设置需要复制的数据库 需要复制的主数据库名字</span></span><br><span class="line">binlog-do-db=test</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">设置logbin格式 Row、Statement、Mixed</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">Disabling symbolic-links is recommended to prevent assorted security risks 关闭配置外存储</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">修改从服务配置文件：vim /etc/my.cnf</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">主服务器唯一ID</span></span><br><span class="line"> [mysqld]</span><br><span class="line">server-id=2</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">启用二进制日志</span></span><br><span class="line">relay-log=relay-bin</span><br><span class="line">log-bin=mysql-bin#上面两行最重要，下面的可以不配置# 设置不要复制的数据库(可设置多个)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">read_only=1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从服务器只读</span></span><br><span class="line">slave-skip-errors= 1032,1062,1007,1050</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝文件到对应容器</span></span><br><span class="line">docker container cp my.cnf mysqlworker:/etc/mysql/mysql.conf.d</span><br><span class="line">docker container cp my.cnf mysqlmaster:/etc/mysql/mysql.conf.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.重启容器 ,进入 主服务器 配置</span></span><br><span class="line">create user &#x27;worker&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">alter user <span class="string">&#x27;worker&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED with mysql_native_password  by <span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line">alter user &#x27;worker&#x27;@&#x27;%&#x27; IDENTIFIED by &#x27;root&#x27;;</span><br><span class="line">grant replication slave,replication client on *.* to &#x27;worker&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取master 文件状态 填写进从服务器</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show master status;</span></span><br><span class="line">+------------------+----------+--------------+--------------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB         | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+--------------------------+-------------------+</span><br><span class="line">| mysql-bin.000002 |      154 | test         | mysql,information_schema |                   |</span><br><span class="line">+------------------+----------+--------------+--------------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看主服务ip</span></span><br><span class="line">docker inspect –format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; mysqlmaster</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.登录从服务器配置执行</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;172.17.0.3&#x27;,</span><br><span class="line">MASTER_USER=&#x27;worker&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;root&#x27;,</span><br><span class="line">MASTER_PORT=3306, </span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.000005&#x27;,MASTER_LOG_POS=154;</span><br><span class="line"></span><br><span class="line">start slave;</span><br><span class="line">reset master;</span><br><span class="line">set global sql_slave_skip_counter=1;</span><br><span class="line">show slave status \G; </span><br></pre></td></tr></table></figure>



<h1 id="redis部署方案"><a href="#redis部署方案" class="headerlink" title="redis部署方案"></a>redis部署方案</h1><h2 id="redis容器部署"><a href="#redis容器部署" class="headerlink" title="redis容器部署"></a>redis容器部署</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;16379:16379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis1:/etc/redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis1/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="attr">redis2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6380:6380&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;16380:16380&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis2:/etc/redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis2/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">  <span class="attr">redis3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6381:6381&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;16381:16381&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis3:/etc/redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis3/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">  <span class="attr">sentinel1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;26379:26379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sentinel1:/etc/sentinel</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis1/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-sentinel</span> <span class="string">/etc/sentinel/sentinel.conf</span></span><br><span class="line">  <span class="attr">sentinel2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;26380:26379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sentinel1:/etc/sentinel</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis2/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-sentinel</span> <span class="string">/etc/sentinel/sentinel.conf</span></span><br><span class="line">  <span class="attr">sentinel3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sentinel3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;26381:26379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sentinel1:/etc/sentinel</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis3/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-sentinel</span> <span class="string">/etc/sentinel/sentinel.conf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">redisnet:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redisnet</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.120</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">          <span class="attr">gateway:</span> <span class="number">192.168</span><span class="number">.120</span><span class="number">.1</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h2><h3 id="redis-master配置文件"><a href="#redis-master配置文件" class="headerlink" title="redis_master配置文件"></a>redis_master配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">databases 10 </span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#监听 </span><br><span class="line">port 6379</span><br><span class="line">#访问密码 </span><br><span class="line">requirepass 123456</span><br><span class="line">masterauth 123456</span><br><span class="line">#持久化文件路径</span><br><span class="line">dir /data </span><br><span class="line">#持久化文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#启用 RDB 持久化文件的压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line">#如果后台保存出错则停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">#关闭保护模式</span><br><span class="line">protected-mode no</span><br><span class="line">#在空数据库时进行无盘复制加载</span><br><span class="line">repl-diskless-load on-empty-db</span><br><span class="line">#守护进程的方式运行</span><br><span class="line">#daemonize yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#持久化策略</span><br><span class="line">#表示如果在 900 秒（15 分钟）内有至少 1 次数据修改操作，则执行一次 RDB 持久化。</span><br><span class="line">save 900 1 </span><br><span class="line">#在 300 秒（5 分钟）内有至少 10 次数据修改操作，就执行一次 RDB 持久化。</span><br><span class="line">save 300 10     </span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">#日志</span><br><span class="line">logfile redis.log</span><br></pre></td></tr></table></figure>

<h3 id="redis-slave配置文件"><a href="#redis-slave配置文件" class="headerlink" title="redis_slave配置文件"></a>redis_slave配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#实例化数据库</span><br><span class="line">databases 10</span><br><span class="line">bind 0.0.0.0 </span><br><span class="line">#监听</span><br><span class="line">port 6380</span><br><span class="line">#访问密码和主机密码</span><br><span class="line">requirepass 123456</span><br><span class="line">masterauth 123456</span><br><span class="line">#持久化文件路径</span><br><span class="line">dir /data </span><br><span class="line">#持久化文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#指定本地数据存储压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">protected-mode no</span><br><span class="line">repl-diskless-load on-empty-db</span><br><span class="line">#daemonize yes</span><br><span class="line">#protected-mode</span><br><span class="line"></span><br><span class="line">#持久化策略</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">#日志路径</span><br><span class="line">logfile redis.log</span><br><span class="line">replicaof master 6379</span><br></pre></td></tr></table></figure>

<h3 id="sentinel配置文件"><a href="#sentinel配置文件" class="headerlink" title="sentinel配置文件"></a>sentinel配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#vim /usr/local/redis/etc/sentinel.conf</span><br><span class="line"> #操作端口</span><br><span class="line"> #绑定所有网络接口</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#哨兵服务监听的端口。</span><br><span class="line">port 26379</span><br><span class="line">#指定进程 ID 文件的路径</span><br><span class="line">pidfile &quot;/data/redis-sentinel.pid&quot;</span><br><span class="line">#工作目录</span><br><span class="line">dir &quot;/tmp&quot; </span><br><span class="line">#设置访问哨兵的密码</span><br><span class="line">requirepass 123456</span><br><span class="line">#docker必关 不以后台进程方式运行</span><br><span class="line">daemonize no </span><br><span class="line">#关闭保护模式</span><br><span class="line">protected-mode no </span><br><span class="line">#指定日志文件路径</span><br><span class="line">logfile &quot;/data/redis-sentinel.log&quot;</span><br><span class="line">#启用主机名解析</span><br><span class="line">sentinel resolve-hostnames yes</span><br><span class="line">#监控名为redisMaster的主节点，节点名为redis1，端口为 6379，需要至少 2 个哨兵</span><br><span class="line">sentinel monitor redisMaster redis1 6379 2</span><br><span class="line">#该主节点的认证密码</span><br><span class="line">sentinel auth-pass redisMaster 123456</span><br><span class="line">#在指定毫秒数后认为该主节点主观下线。</span><br><span class="line">sentinel down-after-milliseconds redisMaster 100 </span><br><span class="line">#故障转移时同时同步的从节点数量为 1 个</span><br><span class="line">sentinel parallel-syncs redisMaster 1</span><br><span class="line">#故障转移超时时间</span><br><span class="line">sentinel failover-timeout redisMaster 600</span><br></pre></td></tr></table></figure>

<h1 id="Nginx部署方案"><a href="#Nginx部署方案" class="headerlink" title="Nginx部署方案"></a>Nginx部署方案</h1><h2 id="1-核心配置"><a href="#1-核心配置" class="headerlink" title="1 核心配置"></a>1 核心配置</h2><p>找到Nginx安装目录下的conf目录下<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238954970&content_type=Article&match_order=1&q=nginx.conf&zhida_source=entity">nginx.conf</a>文件，Ngnix的基本功能配置是由它提供的。</p>
<h2 id="1-1-配置文件结构"><a href="#1-1-配置文件结构" class="headerlink" title="1.1 配置文件结构"></a>1.1 配置文件结构</h2><p>Nginx的配置文件(conf&#x2F;nginx.conf)整体上分为如下几个部分：</p>
<p><img src="/docker%20%E4%BB%8B%E7%BB%8D.assets/nginx_conf.jpg" alt="img"></p>
<p>配置层级图如下所示。</p>
<p><img src="/docker%20%E4%BB%8B%E7%BB%8D.assets/nginx_conf%E6%9E%B6%E6%9E%84.jpg" alt="img"></p>
<h2 id="1-2-配置文件示例"><a href="#1-2-配置文件示例" class="headerlink" title="1.2 配置文件示例"></a>1.2 配置文件示例</h2><p>一个比较全的配置文件示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下是全局段配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user administrator administrators; <span class="comment">#配置用户或者组，默认为nobody nobody。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">worker_processes 2; <span class="comment">#设置进程数，默认为1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid /nginx/pid/nginx.pid; <span class="comment">#指定nginx进程运行文件存放地址</span></span></span><br><span class="line">error_log log/error.log debug;#制定日志路径，级别：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">events段配置信息</span></span><br><span class="line">events &#123;</span><br><span class="line">accept_mutex on;#设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">multi_accept on;#设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">use epoll; <span class="comment">#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span></span><br><span class="line">worker_connections 1024;#最大连接数，默认为512</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http、配置请求信息</span></span><br><span class="line">http &#123;</span><br><span class="line">include mime.types;#文件扩展名与文件类型映射表</span><br><span class="line">default_type application/octet-stream;#默认文件类型，默认为text/plain</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">access_log off; <span class="comment">#取消服务日志</span></span></span><br><span class="line">log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;;#自定义格式</span><br><span class="line">access_log log/access.log myFormat;#combined为日志格式的默认值</span><br><span class="line">sendfile on;#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">sendfile_max_chunk 100k;#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">keepalive_timeout 65;#连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line"></span><br><span class="line">upstream mysvr &#123;</span><br><span class="line">server 127.0.0.1:7878;</span><br><span class="line">server 192.168.10.121:3333 backup;#热备</span><br><span class="line">&#125;</span><br><span class="line">error_page 404 https://www.baidu.com;#错误页</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个Server区块开始，表示一个独立的虚拟主机站点</span></span><br><span class="line">server &#123;</span><br><span class="line">keepalive_requests 120;#单连接请求上限次数。</span><br><span class="line">listen 4545;#监听端口</span><br><span class="line">server_name 127.0.0.1;#监听地址</span><br><span class="line">location ~*^.+$ &#123;#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root path; <span class="comment">#根目录</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">index vv.txt; <span class="comment">#设置默认页</span></span></span><br><span class="line">proxy_pass http://mysvr;#请求转向mysvr 定义的服务器列表</span><br><span class="line">deny 127.0.0.1;#拒绝的ip</span><br><span class="line">allow 172.18.5.54;#允许的ip</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-3-locat路径映射讲解"><a href="#1-3-locat路径映射讲解" class="headerlink" title="1.3 locat路径映射讲解"></a>1.3 locat路径映射讲解</h2><h3 id="1-3-1格式："><a href="#1-3-1格式：" class="headerlink" title="1.3.1格式："></a>1.3.1格式：</h3><p>location [ &#x3D; | ~ | ~ <em>| !~ | !~</em> | @ ] uri {…}</p>
<h3 id="1-3-2解释："><a href="#1-3-2解释：" class="headerlink" title="1.3.2解释："></a>1.3.2解释：</h3><p>&#x3D; 表示精确匹配，如果找到，立即停止搜索并立即处理此请求。<br>~ 表示执行一个正则匹配，区分大小写匹配<br>~ <em>表示执行一个正则匹配，不区分大小写匹配</em><br><em>!~ 区分大小写不匹配</em><br><em>!~</em> 不区分大小写不匹配<br>^~ 即表示只匹配普通字符（空格）。使用前缀匹配，^表示“非”，即不查询正则表达式。如果匹配成功，则不再匹配其他location。<br>@ 指定一个命名的location，一般只用于内部重定向请求。例如 error_page, try_files<br>uri 是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式；</p>
<h3 id="1-3-3优先级和示例："><a href="#1-3-3优先级和示例：" class="headerlink" title="1.3.3优先级和示例："></a>1.3.3优先级和示例：</h3><p>[不加] &lt; [<del>&#x2F;</del>*] &lt; [^~] &lt; [&#x3D;]<br>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">精确匹配/，主机名后面不能带任何字符串 /</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只匹配http://abc.com</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://abc.com [匹配成功]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://abc.com/index [匹配失败]</span></span><br><span class="line">&#125;</span><br><span class="line">location ^~/img/&#123;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以 /img/ 开头的请求，都会匹配上</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://abc.com/img/a.jpg [成功]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://abc.com/img/b.mp4 [成功]</span></span><br><span class="line">&#125;</span><br><span class="line">location ~*/Example/&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">则会忽略 uri 部分的大小写</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://abc.com/test/Example/ [匹配成功]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://abc.com/example/ [匹配成功]</span></span><br><span class="line">&#125;</span><br><span class="line">location /documents &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有正则表达式可以匹配，则优先匹配正则表达式。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://abc.com/documentsabc [匹配成功]</span></span><br><span class="line">&#125;</span><br><span class="line">location /&#123;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://abc.com/abc [匹配成功]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2 反向代理"></a>2 反向代理</h2><h2 id="2-1-反向代理概念："><a href="#2-1-反向代理概念：" class="headerlink" title="2.1 反向代理概念："></a>2.1 反向代理概念：</h2><p>反向代理(Reverse Proxy)是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。<br>反向代理通过proxy_pass指令来实现。</p>
<h2 id="2-2-反向代理示例："><a href="#2-2-反向代理示例：" class="headerlink" title="2.2 反向代理示例："></a>2.2 反向代理示例：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 定义负载均衡后端服务器</span><br><span class="line">upstream tomcat_servers &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server fr_tomcat1:8080;</span><br><span class="line">    server fr_tomcat2:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP 服务器配置</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name fr_nginx;</span><br><span class="line"></span><br><span class="line">    # 反向代理配置</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 将根路径 / 重写为 /fr/decision</span><br><span class="line">        rewrite ^/$ /fr/decision break;</span><br><span class="line"></span><br><span class="line">        # 转发请求到后端服务器</span><br><span class="line">        proxy_pass http://tomcat_servers;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当我们访问localhost的时候，ngnix就将我们的请求转到 localhost:8081了</p>
<h2 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3 负载均衡"></a>3 负载均衡</h2><h2 id="3-1-负载均衡概念："><a href="#3-1-负载均衡概念：" class="headerlink" title="3.1 负载均衡概念："></a>3.1 负载均衡概念：</h2><p>当有2台或以上服务器时，代理服务器根据规则将请求分发到指定的服务器上处理。</p>
<h2 id="3-2-负载均衡策略及示例："><a href="#3-2-负载均衡策略及示例：" class="headerlink" title="3.2 负载均衡策略及示例："></a>3.2 负载均衡策略及示例：</h2><p>Nginx目前支持多种负载均衡策略，这里讲解常用的6种。</p>
<h3 id="3-2-1RR-round-robin-轮询-默认-："><a href="#3-2-1RR-round-robin-轮询-默认-：" class="headerlink" title="3.2.1RR(round robin :轮询 默认)："></a>3.2.1<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238954970&content_type=Article&match_order=1&q=RR&zhida_source=entity">RR</a>(round robin :轮询 默认)：</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器down掉，能自动剔除。轮询是默认配置，不需要太多的配置<br>同一个项目分别使用8081和8082端口启动项目</p>
<ol>
<li><code>upstream web_servers &#123;</code></li>
<li><code>server localhost:8081;</code></li>
<li><code>server localhost:8082;</code></li>
<li><code>&#125;</code></li>
<li></li>
<li></li>
<li><code>server &#123;</code></li>
<li><code>listen 80;</code></li>
<li><code>server_name localhost;</code></li>
<li><code>#access_log logs/host.access.log main;</code></li>
<li><code>location /``&#123;</code></li>
<li><code>proxy_pass http://web_servers;</code></li>
<li><code>proxy_set_header Host $host:$server_port;</code></li>
<li><code>&#125;</code></li>
<li><code>&#125;</code></li>
</ol>
<h3 id="3-2-2-热备："><a href="#3-2-2-热备：" class="headerlink" title="3.2.2 热备："></a>3.2.2 热备：</h3><p>假设有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂了，服务器处理请求的顺序：BBBBBBBBBBBBBB…..</p>
<ol>
<li><code>upstream web_servers &#123;</code></li>
<li><code>server 127.0.0.1:7878;</code></li>
<li><code>server 192.168.10.121:3333 backup;``#热备</code></li>
<li><code>&#125;</code></li>
</ol>
<h3 id="3-2-3-权重"><a href="#3-2-3-权重" class="headerlink" title="3.2.3 权重"></a>3.2.3 权重</h3><p>跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB….。</p>
<ol>
<li><code>upstream web_servers &#123;</code></li>
<li><code>server localhost:8081 weight=1;</code></li>
<li><code>server localhost:8082 weight=2;</code></li>
<li><code>&#125;</code></li>
</ol>
<h3 id="3-2-4-ip-hash"><a href="#3-2-4-ip-hash" class="headerlink" title="3.2.4 ip_hash"></a>3.2.4 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238954970&content_type=Article&match_order=1&q=ip_hash&zhida_source=entity">ip_hash</a></h3><p>这样每个ip地址固定访问一个后端服务器，可以解决session的问题。</p>
<ol>
<li><code>upstream test &#123;</code></li>
<li><code>ip_hash;</code></li>
<li><code>server localhost:8080;</code></li>
<li><code>server localhost:8081;</code></li>
<li><code>&#125;</code></li>
</ol>
<h3 id="3-2-5-fair-第三方"><a href="#3-2-5-fair-第三方" class="headerlink" title="3.2.5 fair(第三方)"></a>3.2.5 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238954970&content_type=Article&match_order=1&q=fair&zhida_source=entity">fair</a>(第三方)</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应。</p>
<ol>
<li><code>upstream backend &#123;</code></li>
<li><code>fair;</code></li>
<li><code>server localhost:8080;</code></li>
<li><code>server localhost:8081;</code></li>
<li><code>&#125;</code></li>
</ol>
<h3 id="3-2-6-url-hash-第三方"><a href="#3-2-6-url-hash-第三方" class="headerlink" title="3.2.6 url_hash(第三方)"></a>3.2.6 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238954970&content_type=Article&match_order=1&q=url_hash&zhida_source=entity">url_hash</a>(第三方)</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，hash_method是使用的hash算法</p>
<ol>
<li><code>upstream backend &#123;</code></li>
<li><code>hash_method crc32;</code></li>
<li><code>hash $request_uri;</code></li>
<li><code>server localhost:8080;</code></li>
<li><code>server localhost:8081;</code></li>
<li><code>&#125;</code></li>
</ol>
<p>以上6种负载均衡各自适用不同情况下单独或者混合使用，可以根据实际情况选择使用，fair和url_hash需要安装第三方模块才能使用。</p>
<h2 id="4-动静分离："><a href="#4-动静分离：" class="headerlink" title="4 动静分离："></a>4 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238954970&content_type=Article&match_order=1&q=%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB&zhida_source=entity">动静分离</a>：</h2><h2 id="4-1-动静分离概念："><a href="#4-1-动静分离概念：" class="headerlink" title="4.1 动静分离概念："></a>4.1 动静分离概念：</h2><p>动静分离是指在web服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性。</p>
<h2 id="4-2-动静分离示例："><a href="#4-2-动静分离示例：" class="headerlink" title="4.2 动静分离示例："></a>4.2 动静分离示例：</h2><ol>
<li><code>upstream web_servers &#123;</code></li>
<li><code>server localhost:8081;</code></li>
<li><code>server localhost:8082;</code></li>
<li><code>&#125;</code></li>
<li><code>server &#123;</code></li>
<li><code>listen 80;</code></li>
<li><code>server_name localhost;</code></li>
<li><code>set $doc_root /usr/local/var/www;</code></li>
<li></li>
<li><code>location ~* \.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123;</code></li>
<li><code>root $doc_root/img;</code></li>
<li><code>&#125;</code></li>
<li><code>location /``&#123;</code></li>
<li><code>proxy_pass http://web_servers;</code></li>
<li><code>proxy_set_header Host $host:$server_port;</code></li>
<li><code>&#125;</code></li>
<li><code>error_page 500``502``503``504``/50x.html;``#出现``500``502``503``504错误时走内部跳转</code></li>
<li><code>location =``/50x.html &#123;</code></li>
<li><code>root $doc_root;</code></li>
<li><code>&#125;</code></li>
<li><code>&#125;</code></li>
</ol>
<p>结果：访问<a href="https://link.zhihu.com/?target=http://localhost/test.jpg">http://localhost/test.jpg</a> 时直接返回&#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;img路径下的图片.<br>访问<a href="https://link.zhihu.com/?target=http://localhost/index.html">http://localhost/index.html</a> 就会访问后端服务器(tomcat等)</p>
<h2 id="5-其他常用的指令："><a href="#5-其他常用的指令：" class="headerlink" title="5 其他常用的指令："></a>5 其他常用的指令：</h2><h2 id="5-1-return指令"><a href="#5-1-return指令" class="headerlink" title="5.1.return指令"></a>5.1.return指令</h2><p>返回http状态码和可选的第二个参数可以是重定向的URL</p>
<ol>
<li><code>return code [text];</code></li>
<li><code>return code URL;</code></li>
<li><code>return URL;</code></li>
<li><code>例如：</code></li>
<li><code>location /``&#123;</code></li>
<li><code>return``404;``# 直接返回状态码</code></li>
<li><code>&#125;</code></li>
<li><code>location /``&#123;</code></li>
<li><code>return``404``&quot;pages not found&quot;;``# 返回状态码 + 一段文本</code></li>
<li><code>&#125;</code></li>
<li><code>location /``&#123;</code></li>
<li><code>return``302``/bbs ;``# 返回状态码 + 重定向地址</code></li>
<li><code>&#125;</code></li>
<li><code>location /``&#123;</code></li>
<li><code>return https://www.baidu.com ; # 返回重定向地址</code></li>
<li><code>&#125;</code></li>
</ol>
<h2 id="5-2-rewrite指令"><a href="#5-2-rewrite指令" class="headerlink" title="5.2 rewrite指令"></a>5.2 rewrite指令</h2><p>重写URI请求 rewrite，通过使用rewrite指令在请求处理期间多次修改请求URI，该指令具有一个可选参数和两个必需参数。<br>第一个(必需)参数是请求URI必须匹配的正则表达式。<br>第二个参数是用于替换匹配URI的URI。<br>可选的第三个参数重写策略</p>
<ul>
<li>last 重写后的 URL 发起新请求，再次进入 server 段，重试 location 的中的匹配；</li>
<li>break 直接使用重写后的 URL ，不再匹配其它 location 中语句；</li>
<li>redirect 返回302临时重定向；</li>
<li>permanent 返回301永久重定向；</li>
</ul>
<ol>
<li><code>location /users/``&#123;</code></li>
<li><code>rewrite ^/users/(.*)$ /show?user=$1 break;</code></li>
<li><code>&#125;</code></li>
</ol>
<h2 id="5-3-error-page指令"><a href="#5-3-error-page指令" class="headerlink" title="5.3 error_page指令"></a>5.3 error_page指令</h2><p>使用error_page指令，您可以配置NGINX返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他URI。在以下示例中，error_page指令指定要返回404页面错误代码的页面(&#x2F;404.html)。</p>
<ol>
<li><code>server&#123;</code></li>
<li><code>error_page 500``502``503``504``/50x.html;</code></li>
<li><code>location =/50x.html&#123;</code></li>
<li><code>root html;</code></li>
<li><code>&#125;</code></li>
<li><code>&#125;</code></li>
</ol>
<h2 id="5-4-日志"><a href="#5-4-日志" class="headerlink" title="5.4 日志"></a>5.4 日志</h2><p>访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开log_format、access_log注释</p>
<ol>
<li><code>log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</code></li>
<li><code>&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</code></li>
<li><code>&#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</code></li>
<li></li>
<li></li>
<li><code>access_log /usr/local/etc/nginx/logs/host.access.log main;</code></li>
<li></li>
<li></li>
<li><code>gzip on</code></li>
</ol>
<h2 id="5-5-deny-、allow指令"><a href="#5-5-deny-、allow指令" class="headerlink" title="5.5 deny 、allow指令"></a>5.5 deny 、allow指令</h2><ol>
<li><code>#禁止访问某个目录</code></li>
<li><code>location /``&#123;</code></li>
<li><code>allow 192.168.0.0;</code></li>
<li><code>allow 127.0.0.1;</code></li>
<li><code>deny all;</code></li>
<li><code>#这段配置值允许192.168.0./24网段和127.0.0.1的请求，其他来源IP全部拒绝。</code></li>
<li><code>&#125;</code></li>
</ol>
<h2 id="5-6-内置变量"><a href="#5-6-内置变量" class="headerlink" title="5.6 内置变量"></a>5.6 内置变量</h2><p>nginx的配置文件中可以使用的内置变量以美元符$开始。其中，大部分预定义的变量的值由客户端发送携带。<br>$args ：#这个变量等于请求行中的参数，同$query_string<br>$content_length ：请求头中的Content-length字段。<br>$content_type ：请求头中的Content-Type字段。<br>$document_root ：当前请求在root指令中指定的值。<br>$host ：请求行的主机名，为空则为请求头字段 Host 中的主机名，再为空则与请求匹配的server_name<br>$http_user_agent ：客户端agent信息<br>$http_cookie ：客户端cookie信息<br>$limit_rate ：这个变量可以限制连接速率。<br>$request_method ：客户端请求的动作，通常为GET或POST。<br>$remote_addr ：客户端的IP地址。<br>$remote_port ：客户端的端口。<br>$remote_user ：已经经过Auth Basic Module验证的用户名。<br>$request_filename ：当前请求的文件路径，由root或alias指令与URI请求生成。<br>$scheme ：HTTP方法（如http，https）。<br>$server_protocol ：请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。<br>$server_addr ：服务器地址，在完成一次系统调用后可以确定这个值。<br>$server_name ：服务器名称。<br>$server_port ：请求到达服务器的端口号。<br>$request_uri ：包含请求参数的原始URI，不包含主机名，如：”&#x2F;foo&#x2F;bar.php?arg&#x3D;baz”。<br>$uri ：不带请求参数的当前URI，$uri不包含主机名，如”&#x2F;foo&#x2F;bar.html”。<br>$document_uri ：与$uri相同</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>Ngnix是一款高性能反向代理服务器，学习它非常有必要，本文讲解了Ngnix核心配置，介绍了反向代理，负载均衡，动静分离三大功能，最后扩展了一些常用的指令。本文介绍了Ngnix的基础用法，后续的Ngnix内核以及原理部分有待研究。</p>
</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/lita6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/headimage.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yinjin Yao</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/cryingatnight/cryingatnight.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1816192779@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-%E4%BB%8B%E7%BB%8D"><span class="toc-text">Docker 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">Docker软件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF"><span class="toc-text">Docker 开源项目背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%9A%84%E6%BC%94%E5%8C%96"><span class="toc-text">Docker的演化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">Docker的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BA%A4%E4%BB%98%E5%92%8C%E9%83%A8%E7%BD%B2"><span class="toc-text">更快的交付和部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8"><span class="toc-text">更高效的资源利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E8%BD%BB%E6%9D%BE%E7%9A%84%E8%BF%81%E7%A7%BB%E5%92%8C%E6%89%A9%E5%B1%95"><span class="toc-text">更轻松的迁移和扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%92%8Cvmware%E6%8A%80%E6%9C%AF%E6%AF%94%E8%BE%83"><span class="toc-text">Docker和vmware技术比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-text">Docker和虚拟化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E4%BB%8B%E7%BB%8D"><span class="toc-text">Docker镜像介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">Docker容器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-text">Docker仓库介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-text">docker三剑客</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-compose"><span class="toc-text">Docker compose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-machine"><span class="toc-text">docker machine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-Swarm"><span class="toc-text">docker Swarm</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-%E5%AE%89%E8%A3%85"><span class="toc-text">Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows%E5%AE%89%E8%A3%85"><span class="toc-text">windows安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#centos%E5%AE%89%E8%A3%85"><span class="toc-text">centos安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85"><span class="toc-text">脚本安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#images%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8"><span class="toc-text">images镜像使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-text">获取镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-pull%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image pull命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F"><span class="toc-text">查看镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-inspect%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image inspect命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B8%85%E7%90%86%E9%95%9C%E5%83%8F"><span class="toc-text">删除清理镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-rm%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image rm命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-prune%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image prune命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-build"><span class="toc-text">docker image build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-save%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image save命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">使用Dockerfile创建镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%87%BA%E4%BB%A5%E5%8F%8A%E8%BD%BD%E5%85%A5%E9%95%9C%E5%83%8F"><span class="toc-text">存出以及载入镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-push%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image push命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-load%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image load命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-image-import%E5%91%BD%E4%BB%A4"><span class="toc-text">docker image import命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#container%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">container容器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">创建启动容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-container-create%E5%91%BD%E4%BB%A4"><span class="toc-text">docker container create命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-start%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">docker start启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-run%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">docker run新建并启动容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">停止容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E2%80%93rm%E6%9A%82%E5%81%9C%E5%AE%B9%E5%99%A8"><span class="toc-text">docker –rm暂停容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-stop%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">docker stop终止容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">进入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-attach%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">docker attach进入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-exec-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">docker exec 进入容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-text">删除容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-rm%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-text">docker rm删除容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">导入和导出容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-export%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">docker export导出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-import%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">docker import导入容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#export%E5%92%8Csave-commit%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">export和save,commit的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8"><span class="toc-text">查看容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-container-ls%E5%91%BD%E4%BB%A4"><span class="toc-text">docker container ls命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-logs%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E8%BE%93%E5%87%BA"><span class="toc-text">docker logs查看容器输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-inspect%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E8%AF%A6%E6%83%85"><span class="toc-text">docker inspect查看容器详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-top%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%9B%E7%A8%8B"><span class="toc-text">docker top查看容器内进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-stats%E6%9F%A5%E7%9C%8B%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">docker stats查看统计信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">其他容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-cp%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">docker cp复制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-diff%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%8F%98%E6%9B%B4"><span class="toc-text">docker diff查看容器变更</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-port%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-text">docker port查看端口映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-update%E6%9B%B4%E6%96%B0%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">docker update更新容器配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E4%BB%93%E5%BA%93%E4%BD%BF%E7%94%A8"><span class="toc-text">Docker仓库使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-text">Docker数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8D%B7-Data-Volumes"><span class="toc-text">创建数据卷(Data Volumes)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">查看所有的数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-text">查看指定数据卷的详细信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">删除数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">创建一个挂载数据卷的容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">数据卷容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">新建数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">进入数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">利用数据卷容器来迁移数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BA%92%E8%81%94"><span class="toc-text">Docker端口映射和数据互联</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="toc-text">端口映射实现容器访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%98%A0%E5%B0%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">端口的映射五种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="toc-text">docker容器互联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E2%80%93link"><span class="toc-text">docker –link</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E4%BA%94%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B"><span class="toc-text">docker五种基础网络类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">创建自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89macvlan%E7%BD%91%E7%BB%9C"><span class="toc-text">自定义macvlan网络</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%82%E8%BD%BD"><span class="toc-text">Docker文件夹挂载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-text">Dockerfile文件说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docer-K8S"><span class="toc-text">docer K8S</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-compose"><span class="toc-text">docker compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose-%E5%AE%89%E8%A3%85"><span class="toc-text">docker compose 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compose-YAML%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-text">compose YAML文件编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">YAML文件格式&#96;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">YAML常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-text">docker-compose操作指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-text">指令集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E"><span class="toc-text">mysql一主一从</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">工作过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-text">请求流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F"><span class="toc-text">方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%A4%8D%E5%88%B6"><span class="toc-text">语句复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">行数据复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">混合类型的复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F"><span class="toc-text">延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-text">数据丢失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95"><span class="toc-text">横向扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-text">数据安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-text">数据分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E8%B7%9D%E7%A6%BB%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83"><span class="toc-text">远距离数据分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E8%AE%BF%E9%97%AE"><span class="toc-text">拆分访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88"><span class="toc-text">redis部署方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2"><span class="toc-text">redis容器部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">redis配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-master%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">redis_master配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-slave%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">redis_slave配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">sentinel配置文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88"><span class="toc-text">Nginx部署方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="toc-text">1 核心配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1.1 配置文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.2 配置文件示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-locat%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84%E8%AE%B2%E8%A7%A3"><span class="toc-text">1.3 locat路径映射讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">1.3.1格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">1.3.2解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">1.3.3优先级和示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">2 反向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">2.1 反向代理概念：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">2.2 反向代理示例：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">3 负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">3.1 负载均衡概念：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">3.2 负载均衡策略及示例：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1RR-round-robin-%E8%BD%AE%E8%AF%A2-%E9%BB%98%E8%AE%A4-%EF%BC%9A"><span class="toc-text">3.2.1RR(round robin :轮询 默认)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%83%AD%E5%A4%87%EF%BC%9A"><span class="toc-text">3.2.2 热备：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E6%9D%83%E9%87%8D"><span class="toc-text">3.2.3 权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-ip-hash"><span class="toc-text">3.2.4 ip_hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-fair-%E7%AC%AC%E4%B8%89%E6%96%B9"><span class="toc-text">3.2.5 fair(第三方)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-url-hash-%E7%AC%AC%E4%B8%89%E6%96%B9"><span class="toc-text">3.2.6 url_hash(第三方)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%EF%BC%9A"><span class="toc-text">4 动静分离：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">4.1 动静分离概念：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">4.2 动静分离示例：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%9A"><span class="toc-text">5 其他常用的指令：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-return%E6%8C%87%E4%BB%A4"><span class="toc-text">5.1.return指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-rewrite%E6%8C%87%E4%BB%A4"><span class="toc-text">5.2 rewrite指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-error-page%E6%8C%87%E4%BB%A4"><span class="toc-text">5.3 error_page指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%97%A5%E5%BF%97"><span class="toc-text">5.4 日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-deny-%E3%80%81allow%E6%8C%87%E4%BB%A4"><span class="toc-text">5.5 deny 、allow指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-text">5.6 内置变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-text">6 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1970/01/01/typora/%E5%BD%B1%E5%88%80RPA/" title="adaad"><img src="/img/lita3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="adaad"/></a><div class="content"><a class="title" href="/1970/01/01/typora/%E5%BD%B1%E5%88%80RPA/" title="adaad">adaad</a><time datetime="2025-07-19T11:05:06.673Z" title="更新于 2025-07-19 19:05:06">2025-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/19/typora/docker/" title="无标题"><img src="/img/lita4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/07/19/typora/docker/" title="无标题">无标题</a><time datetime="2025-07-18T01:01:56.594Z" title="更新于 2025-07-18 09:01:56">2025-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/hello-world/" title="Hello World"><img src="/img/lita5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/07/17/hello-world/" title="Hello World">Hello World</a><time datetime="2025-07-17T15:26:59.840Z" title="更新于 2025-07-17 23:26:59">2025-07-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/lita6.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Yinjin Yao</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div><div class="footer_custom_text">感谢阅读</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入以搜索内容..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>